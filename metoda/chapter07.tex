\chapter[Моделирование полной платформы]{Моделирование полной платформы. Дискретная симуляция событий}\label{chapter07}

\dictum[Китайская пословица]{Путь в тысячу миль начинается с одного шага}

В предыдущих главах подробно разбираются различные методики эффективного моделирования центральных процессорных устройств (точнее, пары «процессор плюс рудиментарная модель внешней памяти»). Однако современные вычислительные комплексы сложнее в своём устройстве: во-первых, они  состоят из множества независимых устройств, большинство которых сильно отличается от ЦПУ по принципам своей работы (и, как мы дальше увидим, их симуляция также производится  другим образом); во-вторых, в одной системе может быть больше одного процессора. В реальности все устройства должны работать одновременно, тогда как модели исполняются последовательно в одном потоке (вопросы параллельных моделей составляют отдельную объёмную тему и будут рассмотрены в главе~\ref{chapter08}). Рассмотрим существующие подходы к решению указанных задач.

\section{Дискретная модель событий}

Наиболее общая методология описания произвольных дискретных систем опирается на следующие упрощающие предположения о поведении их компонент.

\subsection{Дискретность событий и времени}

Во-первых, напомним, что необходимое условие для моделирования системы --- возможность полного описания её состояния (получаемого как сумма состояний входящих в неё подсистем, т.е. устройств) в конечном количестве ячеек памяти. Любое событие заключается в изменении этого состояния.

В реальных электронных системах практически все процессы передачи информации происходят в течение некоторого промежутка времени. Например, при передаче 8 бит по кабелю последовательного порта существует момент начала передачи, соответствующий первому биту, и момент, соответствующий передаче последнего.

В дискретной модели событий мы предполагаем, что каждое событие и связанные с ним изменения в состоянии модели происходят «мгновенно» в момент, соответствующий моменту завершения процесса. Таким образом, мы избавляемся от необходимости изучать течение события целиком. Если окажется, что точности такого представления недостаточно, единое событие заменяется на несколько более мелких, каждое из которых дискретно.

Окружающее нас время непрерывно, и не существует общепризнанных физических доказательств его дискретности, т.е. существования мельчайшего неделимого промежутка времени. Поэтому и дискретные события могут быть привязаны к непрерывным моментам времени. Однако в цифровых синхронных системах время дискретно, при этом мельчайшим интервалом является один цикл генератора тактовых импульсов, причем моменты дискретных событий в такой системе привязаны к границам тактов.

Уточним дополнительно понятие <<событие>>: изменение состояния системы или порождение одного или более новых событий, которые запланированы произойти в будущем. Например, некоторый таймер, будучи включённым, генерирует прерывание каждые 10 тактов. Тогда событие этого устройства заключается в изменении состояния сигнальной шины и создании следующего события, отдалённого на 10 тактов в будущее.

\subsection{Симуляция с фиксированным шагом}

Симуляция с фиксированным шагом (\abbr time stepped)~\cite{ferscha-1995-pdes} --- наверное, самая первая идея, которая приходит на ум. Интуитивно понятно, что для цифровых систем, управляемых тактовым генератором с фиксированной частотой, существует минимальный интервал времени $\Delta t$, разделяющий события. В таком случае алгоритм состоит в том, чтобы продвигать симулируемое время скачками $\Delta t$, на каждом шаге исполняя все события, случившиеся на этом шаге, если их число больше нуля.

Это последнее обстоятельство играет существенную роль. В реальности далеко не на каждом такте происходят какие-либо события, требующие симуляции. Большую часть времени симулятор будет останавливаться только для того, чтобы обнаружить, что на текущем такте делать нечего. Конечно, это обстоятельство ограничивает скорость симуляции.

Отметим, что моделирование процессоров с помощью интерпретации является примером симуляции с фиксированным шагом, равным длительности одной инструкции.

\subsection{Симуляция, управляемая событиями}

Рассмотрим более эффективную схему симуляции, иногда характеризуемую как управляемая событиями (\abbr event driven). Продвижение симулируемого времени при этом делается <<скачками>> от одного события до следующего.

Мы интерпретируем события как изменение состояния одного или нескольких моделируемых устройств. Это позволяет нам упорядочить события всей системы по значениям меток времени, когда они должны произойти. Соответственно моделироваться они будут в указанном порядке. 

В практических реализациях для хранения событий используется структура данных очередь с приоритетами, в которую добавляются новые события, создаваемые при обработке уже существующих. Процесс моделирования сводится к выборке запланированных событий в правильном порядке и их «выполнение» (т.е. изменение состояний согласно тому, что представляют события). На рис.~\ref{fig:queue1} приведён пример состояния очереди событий для некоторой системы.  

\begin{figure}[htp]
    \centering
    % \includegraphics[width=\textwidth]{./queue1-crop.pdf}
    \begin{tikzpicture}[>=latex, font=\scriptsize]
    \draw[->] (0,0) -- (10,0) node[pos=0.9, below] (sim-time) {Время};

    \foreach \x in { 1, 2, 3, 4, 5, 6, 7, 8, 9} { 
        \draw (\x,-0.15) -- (\x,0.15) node (tick\x) {};
    };
    \node[shape=dart, draw, shape border rotate=270 ] at (2, 0.5) (currevent) {};
    \node[draw, arrow box, arrow box arrows={north:.7cm}, text width=2.5cm, align=center, below = 0cm of currevent] (tsim) {Текущее симулируемое время};
    \node[align=center, above=0.2cm of currevent, text width=2cm]  {Обрабатываемое событие};
    
    \node[shape=dart, draw, shape border rotate=270 ] at (5, 0.5) (futureevent) {};
    \node[align=center, above=0.2cm of futureevent, text width=2cm] {Запланированное событие};
    
    \node[fill=black!10, shape=dart, draw, shape border rotate=270 ] at (7, 0.5) (newbornevent) {};
    \node[align=center, above=0.2cm of newbornevent, text width=1.5cm] {Новое событие};
    
    \node[shape=dart, draw, shape border rotate=270 ] at (9, 0.5) (futureevent2) {};
    \node[shape=dart, draw, shape border rotate=270, above=0cm of futureevent2 ] (futureevent3) {};
    
    \draw[dashed, ->] (currevent.south) .. controls +(1,-0.5) and +(-1,-0.5) .. (newbornevent.south); % node[below, pos=0.7, text width=3cm] {Обработка события порождает новое событие в будущем};
        
    \end{tikzpicture}
    \caption[Дискретная симуляция событий]{Дискретная симуляция событий. События привязаны к границам тактов. Показано состояние системы в некоторый момент: несколько запланированы в будущем, одно исполняется, при этом оно порождает новое и добавляет его в очередь}
    \label{fig:queue1}
\end{figure}

\paragraph{Добавление новых событий.} Приоритетом при добавлении новых событий в описанную выше очередь является метка времени. Таким образом, из очереди первыми извлекаются события с наивысшим приоритетом, т.е. с наименьшим значением метки, а при их равенстве у двух событий первым будет добавленный в очередь раньше, т.е. согласно принципу работы очереди.

% Положение нового события в очереди определяется относительно временной позиции события, его порождающего, и характеризуется расстоянием между ними. На последнее в свою очередь накладываются следующие требования.
% \begin{enumerate*}
% \item Оно должно быть строго неотрицательным.
% \item Если задержка равна нулю, то 
% \item 
% \end{enumerate*}

Введённая методика моделирования получила название \textit{симуляции дискретных событий} (\abbr discrete event simulation, DES)~\cite{fujimoto-parallel-dist-sim, introduction-to-des, Cain02preciseand}, которая является достаточно общей: с её помощью можно описать и исследовать поведение очень широкого класса вычислительных устройств, а также любых других систем, никак не связанных с компьютерами. Важным её преимуществом является разделение архитектурного состояния симуляции, хранимого в составе модельных объектов, и порядка вызова обработчиков этого состояния, определяемого единой очередью.

\begin{digression}
По своей сути подход DES во многом схож с тем, что мы наблюдаем при отделении класса цифровых электронных схем от аналоговых, когда изучаемым сигналом становится не напряжение на выходах схем, а логический уровень. Несмотря на то, что схемы не перестают быть подчинены законам физики и напряжение на узлах остаётся аналоговой величиной, принимающей непрерывный диапазон значений, цифровые системы проектируются и должны функционировать таким образом, чтобы для их описания было достаточно лишь двух уровней сигнала. При этом мы пренебрегаем всеми переходными процессами, когда сигнал на входах узлов меняется непрерывным способом, а также тем обстоятельством, что скорость их распространения по проводам ограничена. Всё это позволяет значительно упростить анализ поведения системы, так как мы изолируем важные для нас качества и пренебрегаем частью несущественных свойств. Соответственно границы применимости наших суждений о её последующем поведении определяются справедливостью исходных предположений.
\end{digression}

За значение текущего времени в симулируемой системе принимается значение временной метки последнего обработанного события. Ниже перечислены замечания к описанной выше базовой идее.

\begin{itemize*}
\item Порождаемые события не могут попасть в прошлое, т.е. иметь метку времени меньше, чем текущее время.

\item Обработка событий может не только порождать события в будущем, но и отменять некоторые из них (ещё не обработанные). Пример: описанный ранее таймер с периодом работы 10 тактов получил сигнал о  полном выключении на 5-м такте своей работы. Обработка этого события заключается в изменении внутреннего состояния устройства, а также отмене ранее запланированного события, так как оно уже не произойдёт.

\item Несколько событий могут иметь одинаковую метку времени. Чаще всего придерживаются правила, что они будут обработаны в порядке их добавления в очередь.

\item В модели может существовать больше одной очереди. Например, можно иметь одну очередь, хранящую события, привязанные к инструкциям процессора, а другую --- к фронтам  тактового генератора. Другой вариант --- многопроцессорные системы, в которых с каждым ЦПУ связана своя очередь. Обработка событий из всех очередей происходит в порядке, определяемом принципами работы и требованиями на очерёдность исполнения событий модели.
\end{itemize*}

\section[Два класса моделей]{Два класса моделей}

К настоящему времени мы рассмотрели несколько алгоритмов симуляции устройств. Их можно разделить на два класса по тому признаку, какие силы приводят к изменению состояния участвующих моделей устройств.

\begin{enumerate*}
    \item Внутренние факторы, заложенные в саму модель устройства. Интерпретатор, двоичный транслятор и метод прямого исполнения выполняют шаг за шагом до тех пор, пока не будут остановлены или внешним воздействием (прерыванием, установкой флага исключения и т.п.), или окончанием входных данных (достижение лимита числа исполненных иструкций, времени симуляции и т.п.). Такие модели мы будем называть \textit{исполняющими}, или управляемыми исполнением (\abbr execution driven)
    \item Внешние факторы, стимулирующие модель изменить однократно своё состояние и затем вернуть управление. Любое устройство, входящее в схему DES, является примером такого подхода. Соответствующие им модели --- \textit{неисполняющие}, или управляемые событиями (\abbr event driven).
\end{enumerate*}

Можно заметить, что DES не является самым удобным представлением для моделирования центрального процессора с точки зрения обеспечения высокой производительности симуляции. ЦПУ исполняет инструкции на каждом такте (шаге) своей работы. Необходимость часто проверять состояние очереди событий сводит эффективность «улучшенных» техник (двоичная трансляция, прямое исполнение и т.п.) симуляции на нет. 

В реальных системах обычно присутствуют устройства, некоторые из которых удобно моделировать как исполняющие, тогда как остальные должны быть неисполняющими. Необходимо как-то сочетать оба класса, и для этого существует следующее решение.

\begin{enumerate*}
\item Определяется длительность интервала, в течение которого в моделируемой системе не произойдёт никаких событий. Эта величина равна расстоянию от текущего момента до самого раннего ещё не обработанного события в очереди.

\item Управление передаётся в модель процессора, которая исполняется  некоторое время, не превышающее найденное в первом пункте значение. Затем она останавливается и возвращает управление симулятору.

\item Симулируемое время продвигается на число тактов, потраченных процессором. События обрабатываются по модели DES. Затем мы переходим к первому шагу.
\end{enumerate*}

Схема чередования симуляции исполняющего устройства и обработки событий из очереди событий изображена на рис.~\ref{fig:queue2}.

\begin{figure}[htb]
    \centering
    % \includegraphics[width=\textwidth]{./queue2-crop.pdf}
    \begin{tikzpicture}[>=latex, font=\scriptsize]
    
    \draw[->] (-0.5,0) -- (10.5,0); % node[pos=0.9, above] (sim-time) {Время};

    \begin{scope}
    \clip (0,-2) rectangle (10, 2.5);
    \foreach \x in { 1, 2, 3, 4, 5, 6, 7, 8, 9} { 
        \draw (\x,-0.15) -- (\x,0.15) node (tick\x) {};
    };
    
    \node[shape=dart, draw, shape border rotate=270 ] at (1, 0.5) (event1) {};
    \node[shape=dart, draw, shape border rotate=270 ] at (5, 0.5) (event2) {};
    \node[shape=dart, draw, shape border rotate=270 ] at (9, 0.5) (event3) {};
    
    \node[above of=event2] (desalabel) {Дискретные события};
    \draw[->] (desalabel) -- (event1);
    \draw[->] (desalabel) -- (event2);
    \draw[->] (desalabel) -- (event3);
    
    \draw (3,-0.5) ellipse[x radius = 2cm, y radius = 0.5cm] node {Исполнение процессора} ;
    \draw (7,-0.5) ellipse[x radius = 2cm, y radius = 0.5cm] node {Исполнение процессора} ;
    
    \draw (-1,-0.5) ellipse[x radius = 2cm, y radius = 0.5cm] node {} ;
    \draw (11,-0.5) ellipse[x radius = 2cm, y radius = 0.5cm] node {} ;
    \end{scope}
    \end{tikzpicture}
    \caption{Симуляция исполняющего устройства, перемежающаяся с обработкой дискретных событий}
    \label{fig:queue2}
\end{figure}

В каких случаях следует использовать модели каждого из описанных типов? Устройство выгодно представлять исполняющей моделью, если для него верно следующее:
\begin{enumerate*}
    \item Оно меняет своё состояние каждый или почти каждый такт.
    \item События к нему от сторонних устройств приходят в среднем редко (раз в 100--1000 тактов).
    \item Интерес для исследователя представляют внутренние процессы устройства~\cite{fritzson2004principles}.
\end{enumerate*}

Устройство следует симулировать как неисполняющее, если ему присущи следующие свойства.
\begin{enumerate*}
    \item Изменение его состояния происходит в среднем редко и асинхронно по отношению к остальным устройствам.
    \item Характер взаимодействия с другими агентами представлятся в виде «запрос--отклик».
    \item Оно может быть представлено как «чёрный ящик» без внутренней структуры.
\end{enumerate*}

Совместную работу системы моделей, состоящих как из исполняющих, так и неисполняющих устройств, можно представить как совместную работу двух или более симуляторов (\textit{косимуляцию}), чередующих своё исполнение таким образом, чтобы выдерживались инварианты, определяющие согласованное течение симулируемого времени (рис.~\ref{fig:cosim}).

\begin{figure}[htb]
    \centering
    % \includegraphics[width=0.75\textwidth]{./cosim-crop.pdf}
    \begin{tikzpicture}[>=latex]
    \node[draw, circle, text width = 3cm, text badly centered] (dessim) {Симулятор дискретных событий};
    \node[draw, circle, text width = 3cm, text badly centered, right = 2.5cm of dessim] (execsim) {Модель исполняющего устройства};
    
    \draw (dessim.45)   edge[bend left = 45, ->] (execsim.135);
    \node[above=1cm of execsim.135] {\small Длительность до следующего события};
    \draw (execsim.225) edge[->, bend left = 45] (dessim.315);
    \node[below=1cm of dessim.315] {\small Число исполненных шагов};
    
    \end{tikzpicture}
    \caption[Косимуляция моделей исполняющих устройств и DES]{Косимуляция моделей исполняющих устройств и DES. При каждой передаче управления соответствующая модель сообщает другой о том, насколько было продвинуто симулируемое время}
    \label{fig:cosim}
\end{figure}

Отметим, что то, какую модель устройства --- исполняющую или неисполняющую --- создавать, определяется сценарием работы симулятора в целом и этой модели в его составе. Иногда микропроцессор необходимо моделировать очередью событий, но чаще всего он представляется как исполняющая модель. И наоборот, модель некоторого периферийного устройства может быть исполняющей.

\section{Моделирование многопроцессорных систем}\label{sec:mp-simulation}

Рассмотрим случай, когда в моделируемой системе присутствует более одного исполняющего устройства, например несколько процессоров. При этом в реальности они работают одновременно (параллельно), и данный факт необходимо отразить при их моделировании. Отметим, что устройства взаимодействуют всегда с помощью сообщений, время доставки которых конечно и составляет как минимум один такт.

Самое очевидное решение --- чередовать исполнение всех процессоров на каждом  шаге. В таком случае их состояние и «локальное» симулируемое время всегда будут отличаться не более чем на один такт.

Недостаток подхода тоже легко понять --- такая система будет иметь низкую скорость работы из-за частого переключения моделей и связанного с ними моделируемого состояния. Режимы двоичной трансляции и прямого исполнения невозможно будет задействовать.

Облегчающим обстоятельством является тот факт, что в большинстве случаев нет необходимости выдерживать относительный сдвиг времени процессоров очень малым --- ведь в реальности синхронная работа процессоров не наблюдается, и она не гарантируется исполняющимися на них программами. Поэтому мы можем исполнять отдельные процессоры достаточно большими «кусками», перемежая исполнение всех моделей, которые получают возможность задействовать оптимизирующие техники, например ДТ. 

Отрезок времени, выделяемый устройству на исполнение, именуется \textit{квотой} (другие названия --- квант времени, quota, quantum, time slice). Устройство, находящееся в процессе исполнения в рамках своей квоты, считается текущим. Процесс исполнения многопроцессорной системы проиллюстрирован на рис.~\ref{fig:quota-mp-pt1} и~\ref{fig:quota-mp-pt2}.

\begin{figure}[htb]
    \centering
    % \includegraphics[width=0.7\textwidth]{./quota-mp-crop.pdf}
    \begin{tikzpicture}[>=latex]
        \draw[->] (0,0) -- (8,0) node[pos=0.9, below] (sim-time) {Физическое время};

    \foreach \x in { 1, 2, 3, 4, 5, 6, 7} { 
        \draw (\x,-0.15) -- (\x,0.15) node (tick\x) {};
    };
    \matrix[anchor=south west] at (-0.5,0.5){
        \node[] {CPU3}; & & & \node[shape=single arrow, draw, text width = 2cm, inner xsep = 0cm, fill=black!5] (arr3) {}; \\
        \node {CPU2}; & & \node[shape=single arrow, draw, text width = 2cm, inner xsep = 0cm, fill=black!10] (arr2) {}; & \\
        \node {CPU1}; & \node[shape=single arrow, draw, text width = 2cm, inner xsep = 0cm, fill=black!15] (arr1) {}; & & \\
    };
       
    \draw[->] (arr1.east) -- (arr2.west);
    \draw[->] (arr2.east) -- (arr3.west);
    \end{tikzpicture}
    \caption[Совместная симуляция нескольких процессоров, часть 1]{Совместная симуляция нескольких процессоров. Отдельные интервалы симуляции чередуются на хозяйском процессоре}
    \label{fig:quota-mp-pt1}
\end{figure}

\begin{figure}[htb]
    \centering
    \begin{tikzpicture}[>=latex]
        \draw[->] (0,0) -- (8,0) node[pos=0.9, below] (sim-time) {Симулируемое время};

    \foreach \x in { 1, 2, 3, 4, 5, 6, 7} { 
        \draw (\x,-0.15) -- (\x,0.15) node (tick\x) {};
    };
    \matrix[anchor=south west] at (-0.5,0.5){
        \node {CPU3}; & \node[shape=single arrow, draw, text width = 2cm, inner xsep = 0cm, fill=black!5] (arr3) {};  \\
        \node {CPU2}; & \node[shape=single arrow, draw, text width = 2cm, inner xsep = 0cm, fill=black!10] (arr2) {}; \\
        \node {CPU1}; & \node[shape=single arrow, draw, text width = 2cm, inner xsep = 0cm, fill=black!15] (arr1) {}; \\
    };
       
    % \draw[->] (arr1.east) -- (arr2.west);
    % \draw[->] (arr2.east) -- (arr3.west);
    
    \end{tikzpicture}
    \caption[Совместная симуляция нескольких процессоров, часть 2]{Совместная симуляция нескольких процессоров. В контексте моделируемой системы процесс выглядит как параллельная непрерывная работа}
    \label{fig:quota-mp-pt2}
\end{figure}

\subsection{Замечания к предложенной схеме}

\begin{itemize*}
\item Процессор может исполнить меньше инструкций, чем содержится в выданной ему квоте. Пример причины для ранней остановки --- событие во внешнем устройстве, которое необходимо обработать согласно его метке времени. После обработки всех событий, «мешавших» продвижению текущей модели, она либо может продолжить исполнение остатка своей квоты, либо передать управление другому устройству --- это зависит от деталей алгоритма планировщика.

\item Не следует увлекаться излишне большими квотами, пытаясь ускорить исполнение --- это может негативно повлиять на точность модели, потому что моменты прерывания работы исполняющих моделей являются точками синхронизации состояния всей системы. Между ними каждое устройство работает в полной изоляции, в то время как остальные заморожены и не могут посылать ему никакие сигналы. Если программа, исполняемая в модели, ожидает сообщений от других систем в течение ограниченного времени, то квота не должна превышать это время тайм-аута.

\item В духе модели DES операция переключения текущего исполняющего устройства может быть реализована как псевдособытие, периодически вставляемое в очередь и при своей обработке вызывающее деактивацию текущего и выбор следующего активного процессора.
\end{itemize*}


\iftoggle{hasquiz}{
    \input{chapter07-questions}
}{}

\iftoggle{webpaper}{
    \printbibliography[title={Литература}]
}{}

