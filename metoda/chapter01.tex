\chapter{Применение программных моделей}\label{chapter01}

\dictum[Станислав Лем. Кибериада. Сказки роботов]{\dots цифровая машина, получившая непосильное для неё задание, вместо того, чтобы заниматься решением проблемы самой, строит, если перейдён определённый порог, называемый барьером мудрости, следующую машину\dots }

\section{Введение}

Разработка новых устройств для ЭВМ, таких как центральные процессоры, графические карты и сопроцессоры, наборы системной логики, сетевые карты, а также проектирование вычислительных комплексов и средств их взаимодействия, являются сложными и длительными процессами. Сложность эта обусловлена многими факторами, среди которых можно выделить следующие.

\begin{itemize*}
\item Большое число составляющих систему устройств со сложными взаимосвязями, как явными, так и неявными, скрытыми или даже паразитными.   

\item Необходимость сохранения обратной совместимости с уже существующим оборудованием, дополнительно усложняющая дизайн.

\item Необходимость обеспечения поддержки аппаратуры программными продуктами, помогающими раскрыть их полный потенциал: драйверами для операционных систем, компиляторами, профилировщиками и др. средствами разработки.

\item Необходимость знать характеристики новой технологии (например, производительность, мощность энерговыделения, размеры) как можно раньше, чтобы принимать обоснованные в рамках рыночной конкуренции решения о целесообразноcти создания продуктов на её основе.

\item Важность выявления ошибок проектирования на ранних стадиях. Стоимость исправления недостатков резко возрастает вместе с этапом проектирования, на котором они были обнаружены. Исправить ошибку в описании на бумаге в начале проекта несоизмеримо дешевле, чем отзывать партии бракованных изделий, уже изготовленных по спецификациям, содержащим изъяны (рис.~\ref{fig:error-cost}).

\end{itemize*}

\begin{figure}[htb]
    \centering
    %\includegraphics[width=\textwidth]{./error-cost-crop.pdf}
    \begin{tikzpicture}[scale=0.9, >=latex]
        \draw[->] (0,0) -- (0,6)  node[very near end, right, text width = 3cm, text badly ragged] {\small{Стоимость исправления ошибки}};
		\draw[->] (0,0) -- (11,0) node[very near end, below] {\small Время};
		\path (0, 1) node[left] {$10 \$$};
		\path (0, 5) node[left] {$10^6 \$$};
		%\draw[style=help lines] (7.5,0) -- (7.5,6);
		
		\path (1.7, 0.5) node[ellipse, draw] {\footnotesize Концепция};
		\path (2.5, 1.5) node[ellipse, draw, text width = 2.3cm, text centered] {\footnotesize Функциональный прототип};
		\path (3.5, 2.5) node[ellipse, draw, text width = 2cm, text centered] {\footnotesize Потактовый прототип};
		\path (4.5, 3.5) node[ellipse, draw] {\footnotesize  RTL-модель};
		\path (5.5, 4.5) node[ellipse, draw, text width = 2.8cm, text badly centered, inner sep=0] {\scriptsize Экс\-пе\-ри\-мен\-таль\-ные образцы};
		
		\path (8.5, 5.5) node[starburst, draw] {\footnotesize{Выпуск на рынок}};
    \end{tikzpicture}

    \caption[Рост стоимости исправления ошибки с фазой проектирования устройства]{Рост стоимости исправления ошибки с фазой проектирования устройства. Различные этапы проектирования могут перекрываться во времени, однако каждый из них подразумевает всё большие вложения ресурсов. Ошибки в уже выпущенном продукте могут повлечь за собой существенные финансовые и имиджевые потери для допустившей их компании}
    \label{fig:error-cost}
\end{figure}

По этим причинам широко используется подход, когда разработка нового устройства предваряется созданием и сопровождается использованием его компьютерных моделей, способных с различной точностью проявлять себя так, как работает реальное устройство. Построенные согласно этим принципам инструменты различаются назначением, точностью соответствия реальной аппаратуре, количеством моделируемых и конфигурируемых параметров, скорости выполнения, внутренней организацией и принципами работы. Даже не полностью соответсвующая реальности модель может быть практически полезной.

\begin{digression}
Моделирование возможно благодаря применению общесистемной методики борьбы со сложностью --- модульностью подсистем и абстракцией их функций. Устройства, входящие в состав компьютера, соединяются между собой через строго определённые интерфейсы, диктующие лишь то, что будет передаваться через них и какой тип результата будет возвращён, но не определяющие, что будет располагаться на другом конце. Это позволяет оборудованию различных производителей быть совместимым друг с другом без необходимости раскрытия внутренней документации конкурентам. Также это позволяет подставлять вместо реальных устройств их модели. Более того, по разные стороны интерфейсов мы можем размещать модели различных подсистем, таким образом создавать полную модель всего компьютера, компоненты которой <<не знают>>, что за интерфейсом скрывается не реальное устройство, а его модель~(рис.~\ref{fig:interface}).

\end{digression}

\begin{figure}[htp]
\centering
\begin{tikzpicture}[>=latex, font=\small, minimum height = 2cm, minimum width=2cm]
    \node[draw] (node1) {Подсистема};
    \node[draw, right=3cm of node1, font=\huge, align=center] (node2) {?};
	\draw[->] ([yshift=0.5cm] node1.east) -- ([yshift=0.5cm] node2.west) node[midway, above,minimum height = 0.5cm] {Запрос};
	\draw[->] ([yshift=-0.5cm] node2.west) -- ([yshift=-0.5cm] node1.east) node[midway, above,minimum height = 0.5cm] {Ответ};
\end{tikzpicture}
\caption[Соединение компонент сложной системы через интерфейсы]{Соединение компонент сложной системы через интерфейсы, определяющие форматы запроса и отклика, но не специфицирующие детали реализации необходимой функциональности. Это позволяет заменять некоторые или даже все части такой системы на программные модели}\label{fig:interface}
\end{figure}

% Объединяет их, как правило, общее требование \textit{изоляции} кода, исполняющегося внутри модели: такой код не должен иметь возможности определить, исполняется ли он на реальном <<железе>> или нет, инспектируя доступное ему окружение. Выполнение этого требования почти всегда является необходимым условием корректности модели. Тем не менее иногда оно может быть ослаблено (в системах, использующих паравиртуализацию, см. главу~\ref{chapter13}) в целях обеспечения большего удобства или увеличения скорости работы программной модели. 

\section{Применения моделей ЭВМ}

Перечислим лишь некоторые практические способы применения программных моделей.

\begin{description*}
    
\item[Раннее обнаружение ошибок проектирования.] Программирование --- процесс значительно менее затратный, чем испытания реального железа, и что куда важнее, исправление ошибки в программе занимает минуты, тогда как повторный выпуск опытного образца аппаратуры может занять месяцы. 

\item[Написание сопутствующего аппаратуре ПО.] Ранняя доступность модели устройства позволяет использовать её для разработки драйверов, прошивок (таких как BIOS и UEFI~\cite{uefi-itj}) и даже операционных систем и компиляторов параллельно с разработкой самого устройства. В наше время нередка ситуация, что драйвера для нового оборудования готовы и отлажены ещё до официальной доступности предназначенного для них оборудования.

\item[Построение и исследование экспериментальных решений.] Моделирование позволяет быстрее и дешевле  изучать пространство проектирования (\abbr design space) для определения параметров, при которых устройство или система будет иметь наилучшие характеристики. Для исследователей интерес часто представляют количественные характеристики новых систем, такие как скорость работы, степень загруженности подсистем, потребление энергии и т.п. Иногда подобный анализ можно провести и без симуляции, используя аналитические методики, теорию массового обслуживания, экстраполяцию измерений на существующей аппаратуре и т.д. Однако моделирование даёт наибольшую гибкость.

\item[Качественно-функциональные свойства.] Под этим тер\-ми\-ном понимается изучение, работает или нет новая технология в принципе, безотносительно её скоростных характеристик. В этом случае альтернатив симуляции практически не остаётся, поскольку необходимо изучить функционирование системы.

\item[Выполнение программ на <<неродной>> архитектуре.] В этом случае модель обеспечивает прослойку, позволяющую выполнять приложения без перекомпиляции на машинах, изначально не предназначенных для исполнения этих программ. 

\end{description*}

\section{Терминология}

Существует много терминов, относящихся к изучаемой области моделирования. Определим основные из них, которые будут использоваться в дальнейшем.

\begin{description*}

\item[Эмулятор] (\abbr emulator) --- программа, моделирующая некоторую физическую систему путём имитации внутренней структуры и процессов, происходящих внутри подсистем аппаратуры.

\item[Симулятор] (\abbr simulator) --- программа, моделирующая некоторую физическую систему через предоставление корректных интерфейсов входящих в неё подсистем и обеспечивающая правильное их функционирование, но не гарантирующая того, что их внутреннее устройство будет похоже на устройство аналогичных подсистем реальной ЭВМ (т.е. работающая как <<чёрный ящик>>). 

Следует отметить, что разница в определениях симулятора и эмулятора размыта, поэтому мы будем считать оба термина эквивалентными.

\item[Хозяин] (\abbr host) ---  физическая вычислительная система, на которой исполняются программы, в том числе моделирующие другие ЭВМ. При этом потребляются хозяйские ресурсы (процессорное время, память, электроэнергия и т.п.). Также в литературе встречается синонимичный термин \textit{инструментальная система}.

\item[Гость] (\abbr guest) ---  система, поведение которой призван отражать симулятор и внутри которой исполняются гостевые приложения. Синонимичным является понятие \textit{целевая система} (\abbr target system).

\item[Виртуализация] (\abbr virtualization) --- выполнение одной или более гостевых программ, в т.ч. операционных систем, внутри изолированных друг от друга окружений. При этом управляющая программа, в данном случае называемая \textit{гипервизором} (\abbr hypervisor) или монитором виртуальных машин (\abbr virtual machine monitor, VMM), контролирует доступ виртуализованных приложений к физическим ресурсам системы.  В главе~\ref{chapter14} рассматриваются теоретические и практические аспекты виртуализации. Сейчас же определим два основных типа гипервизоров.

\item[Гипервизоры первого типа] (автономные гипервизоры) работают прямо на хозяйской аппаратуре, т.е. не требуют для своей работы операционной системы, они берут её функции на себя и являются привилегированными приложениями. Данное обстоятельство позволяет минимизировать накладные расходы виртуализации. Вместе с тем при разработке автономного монитора приходится тратить много усилий на поддержку в нём функций операционной системы. На рис.~\ref{fig:vm-type1} приведён пример взаимного расположения программных компонент при использовании гипервизора первого типа.

\begin{figure}[htp]
    \centering
    %\includegraphics[width=0.6\textwidth]{./vm-type1-crop.pdf}
    \begin{tikzpicture}
    \path (-0.5,0) node[below left] (app-win) {Приложения Windows}; \path (0.5,0) node[below right] (app-lin) {Приложения Linux}; 
	\path (-0.5,-1) node[below left, text width=2cm] (win) {Windows};           \path (0.5,-1) node[below right, text width=2cm] (lin) {Linux};
	
	\path (0,-2) node[below] (mon) {Монитор виртуальных машин};
	\path (0,-3) node (hw) {Аппаратура IA-32};
	
	\draw	(node cs:name=app-win, anchor=north west) -- (node cs:name=app-win, anchor=north east) |-
			(0, -2) ; 
	\draw	(node cs:name=app-lin, anchor=north east) -- (node cs:name=app-lin, anchor=north west) |-
			(0, -2) ; 
	
	\draw	(node cs:name=win, anchor=north east) -- (node cs:name=win, anchor=north west) -- 
			(node cs:name=win, anchor=south west);
			
	\draw	(node cs:name=lin, anchor=north west) -- (node cs:name=lin, anchor=north east) -- 
			(node cs:name=lin, anchor=south east);
			
	\draw [snake=snake] (node cs:name=win, anchor=south east) --  
			(perpendicular cs:
			vertical line through  ={(app-win.west)},
			horizontal line through={(win.south east)} 
			);
	\draw [snake=snake] (node cs:name=lin, anchor=south west) --  
			(perpendicular cs:
			vertical line through  ={(app-lin.east)},
			horizontal line through={(lin.south west)} 
			);
			
	\draw[snake=snake] %(node cs:name=hw,anchor=north west) -- (node cs:name=hw,anchor=north east);
	(perpendicular cs:
			vertical line through  ={(app-lin.east)},
			horizontal line through={(hw.north)} 
			) --
	(perpendicular cs:
			vertical line through  ={(app-win.west)},
			horizontal line through={(hw.north)} 
			);
	
	\draw   (node cs:name=hw, anchor=south) -| (node cs:name=app-win, anchor=north west);
	\draw   (node cs:name=hw, anchor=south) -| (node cs:name=app-lin, anchor=north east);
    \end{tikzpicture}

    \caption[Гипервизор первого типа]{Пример использования гипервизора первого типа для одновременного запуска приложений двух различных операционных систем}\label{fig:vm-type1}
\end{figure}

Примеры существующих мониторов виртуальных машин первого типа: VMware ESX(i) Server~\cite{vmware-esx}, Xen~\cite{xen2006}. %См. также раздел~\ref{sec:implementations}.

\item[Гипервизоры второго типа] не заменяют операционную систему, но работают поверх неё как обычное пользовательское приложение (рис.~\ref{fig:vm-type2}), иногда требуя установки драйверов или модулей ядра, работающих с повышенным приоритетом. Примеры таких программных продуктов: Oracle VirtualBox~\cite{virtualbox}, KVM~\cite{kvm-wiki} (\abbr kernel-based virtual machine). Накладные расходы на виртуализацию при их работе выше, чем при использовании мониторов первого типа.

\begin{figure}[htp]
    \centering
%    \includegraphics[width=0.6\textwidth]{./vm-type2-crop.pdf}
    \begin{tikzpicture}
    \path (-0.5,0) node[below left] (app-win) {Приложения Windows};
	
	\path (-0.5,-1) node[below left] (win) {Windows};
	
	\path (-0.5,-2) node[below left] (mon) {Монитор виртуальных машин};  \path (0.5,-2) node[below right] (app-lin) {Приложения Linux};
	\path (0,-3) node[below] (lin) {Linux};
	\path (0,-4) node (hw) {Аппаратура IA-32};
	
	\draw (0, -3) -|
		  (node cs:name=mon, anchor=south east) -| (node cs:name=app-win,anchor=north east) -|
		  (node cs:name=mon, anchor=south west);
	
	\draw (node cs:name=win, anchor=south west) |- (node cs:name=app-win,anchor=south east);

 	\draw	(node cs:name=app-lin, anchor=north east) -- (node cs:name=app-lin, anchor=north west) |-
 			(0, -3) ; 
	
 	\draw   (node cs:name=hw, anchor=south) -| (node cs:name=mon, anchor=north west);
 	\draw   (node cs:name=hw, anchor=south) -| (node cs:name=app-lin, anchor=north east);

		
	\draw [snake=zigzag] (node cs:name=win, anchor=south east) --  
			(perpendicular cs:
			vertical line through  ={(mon.west)},
			horizontal line through={(win.south east)} 
			);
	\draw [snake=snake] (node cs:name=mon, anchor=south west) --  
						(node cs:name=mon, anchor=south east) ;
	\draw [snake=snake] (node cs:name=app-lin, anchor=south west) --  
						(node cs:name=app-lin, anchor=south east) ;
						
						
	\draw[snake=saw]
	(perpendicular cs:
			vertical line through  ={(app-lin.east)},
			horizontal line through={(hw.north)} 
			) --
	(perpendicular cs:
			vertical line through  ={(mon.west)},
			horizontal line through={(hw.north)} 
			);
    \end{tikzpicture}
    \caption[Гипервизор второго типа]{Пример использования гипервизора второго типа для запуска приложений второй операционной системы при уже загруженной основной}\label{fig:vm-type2}
\end{figure}

\item[Полноплатформенный симулятор] (\abbr full platform si\-mu\-la\-tor) --- модель, включающая в себя компоненты, достаточные для получения поведения некоторой ЭВМ в целом, т.е. состоящая как минимум из следующих основных устройств: процессора, памяти, дискового устройства, сетевого устройства, клавиатуры, мыши, монитора и др. Внутри такого симулятора возможно запустить немодифицированную операционную систему, и она будет работать так же, как работала бы на реальной аппаратуре.

\item[Симулятор режима приложения] (\abbr application mode si\-mu\-la\-tor) --- программа, предназначенная для запуска <<обычных>> прикладных приложений (т.е. не операционных систем, BIOS или другого системного ПО). Целевые программы при этом ожидают активное присутствие определённой операционной системы, и потому симулятор обязан в том числе эмулировать необходимые  системные вызовы для того, чтобы создать окружение, неотличимое от предоставляемого операционной системой. При этом модель получается жёстко привязанной к конкретному варианту системного ПО, так как список и формат системных вызовов и прочих интерфейсов приложений может заметно меняться между ОС (например, Windows, Linux и Mac OS имеют разные механизмы вызова операций в контексте ОС) и даже внутри одной ОС между её версиями (например, Linux 2.4 и Linux 2.6). Как правило, количество моделируемого при этом аппаратного обеспечения минимально.

\item[Функциональная модель] (\abbr functional model) --- симулятор, точность которого ограничена корректной функциональностью целевых приложений без обеспечения правильных значений длительностей операций, наблюдаемых в реальности. Например, доступ к памяти возвращает правильное значение, но за один такт моделируемого времени, тогда как в реальности он занял бы от 20 до 100 тактов в зависимости от состояния системы кэшей. Подобные модели недостаточно точны для предсказания производительности, но, как правило, достаточны для корректной работы большинства гостевого ПО, включая операционные системы, так как алгоритмы отдельных инструкций соответствуют реальности.

\item[Потактовая модель] (\abbr cycle precise model, performance model)  --- симулятор, корректно высчитывающий ход времени внутри моделируемой системы. Он моделирует её внутреннее устройство более детально, чем это делается в функциональных моделях. Потактовые модели обычно во много раз медленнее функциональных.

\item[Гибридная модель] (\abbr hybrid model) --- система, частично реализованная в программе для обычной ЭВМ (например, для персонального компьютера), а частично --- на специализированном оборудовании (например, на ПЛИС\footnote{Программируемая логическая интегральная схема.}). Применяется в тех случаях, когда чисто программное моделирующее решение недостаточно быстро.

\end{description*}

\section[Симуляция и виртуализация на различных уровнях]{Симуляция и виртуализация на различных уровнях абстракций исследуемых систем}

Для того чтобы яснее понять сходства различных типов симуляторов, а также более чётко определить специфику термина \emph{виртуализация}, рассмотрим иерархию абстракций, наблюдаемую при работе программы на вычислительной машине, и их место в ней (рис.~\ref{fig:simulation-levels}). 

\begin{figure}[htb]
    \centering
%     \includegraphics[width=0.7\textwidth]{./simulation-levels-crop.pdf}
    \begin{tikzpicture}
    \coordinate (A) at (-4,-4) {};
	\coordinate (B) at ( 4,-4) {};
	\coordinate (C) at ( 0, 0) {};
	\draw (A) -- ($(A)!5/6!(C)$);
	\draw (B) -- ($(B)!5/6!(C)$);
	\draw ($(A)!5/6!(C)$) -- ($(B)!5/6!(C)$);
        \foreach \y/\A/\S in {0/{Логические элементы}/{RTL-модели},
						   1/Микроархитектура/{Потактовые симуляторы},
						   2/Инструкции/{Функциональные симуляторы},
						   3/API/{Симуляторы уровня приложения},
						   4/Поведение/{Аналитические методы}
						   } {
			\draw ($(A)!\y/6!(C)$) -- ($(B)!\y/6!(C)$)
			node[midway,above] {\small\A}
			node[above right = 0.25cm, draw, rectangle callout, callout relative pointer={(185:0.5cm)}] {\scriptsize\S};
		}
    \end{tikzpicture}
    \caption[Место различных типов симуляции]{Место различных типов симуляции в стеке существующих интерфейсов вычислительных систем}
    \label{fig:simulation-levels}
\end{figure}

На самом верхнем уровне находятся её алгоритмы, в общем случае не привязанные к аппаратуре. Поскольку любую последовательность вычислений человек теоретически может провести с использованием ручки и бумаги (оставим в стороне вопрос, сколько времени у него это займёт), то <<имитация>> работы компьютера на этом уровне представляет собой анализ алгоритма самого вычисления. При этом такая аналитическая модель может быть неполной, упрощённой для того, чтобы передать лишь существенные для конкретного исследования аспекты работы, например, только её энергопотребление или только детали взаимодействия с внешними агентами. В этом случае <<хозяйской>> системой является сам человек.

Реальные программы редко бывают написаны полностью с нуля, чаще всего они используют в своей работе сторонние библиотеки, подпрограммы, процедуры, функции и т.п., в том числе сюда относятся сервисы операционной системы --- системные вызовы. Для возможности эффективного взаимодействия кода библиотек и программ вводятся соглашения, такие как интерфейс пользовательских приложений (\abbr application program interface, API) и интерфейс двоичных приложений (\abbr application binary interface, ABI), определяющие форматы передачи входных данных и результатов, а также ожидаемую от подпрограмм функциональность. Симулятор заменяет алгоритм каждого вызова API/ABI другим, с достаточной точностью передающим работу оригинальной подпрограммы и имеющим совместимый формат данных. При этом хозяйские и гостевые системы не обязаны использовать одни и те же соглашения. Таким образом работают модели уровня приложений --- они заменяют операционную систему, ожидаемую пользовательским кодом, набором собственных реализаций API. Примеры описаний программных интерфейсов приложений --- стандарт MPI~\cite{mpi2std} и стандарт OpenMP~\cite{openmp}. Пример документа, описывающего двоичный интерфейс --- AMD64 ABI~\cite{x86-64-abi}.

Если посмотреть в работу приложений ещё глубже, то любой вычислительный процесс состоит из последовательного и параллельного исполнения инструкций одного или более процессоров. Формат и ожидаемая функция каждой из них описаны в специальных документах --- руководствах для разработки программ (\abbr software development manual, SDM). Примеры таких документов для ISA (\abbr instruction set architecture, архитектура набора инструкций):~\cite{intelmanual-7vols, amd-sdm-vol1, weaver1994sparc, arm-sdg, alpha-book}. Функциональный симулятор заменяет алгоритм каждой гостевой инструкции на эквивалентный, но представленный в терминах хозяйской системы.

Исполнение каждой машинной инструкции может быть разделено на несколько стадий, имеющих различную длительность, величина которой может зависеть от ряда факторов. Кроме того, в работе вычислительной системы могут присутствовать процессы, не отражённые на уровне ISA, но тем не менее влияющие на её функционирование, например, работа кэшей или изменение частоты процессора. Для их учёта симулятор должен абстрагировать процессы на ещё более низком, микроархитектурном уровне. При этом становится возможным более точно моделировать времена работы приложений как сумму длительностей микроопераций. Отметим, что документация на данный уровень представления процессоров чаще всего является внутренним секретом компаний, недоступна для независимых разработчиков приложений и может быть получена только при подписании ряда соглашений о неразглашении (\abbr non disclosure agreement, NDA).

Последний рассматриваемый нами уровень абстракции вычислительной системы --- это уровень логических узлов, таких как триггеры, счётчики, отдельные логические элементы И, ИЛИ, НЕ, шины передачи данных и т.п. Их симуляция наиболее точно передаёт внутренние процессы, которые будут происходить при функционировании микросхемы. Работа каждого её узла в модели будет реализована с помощью отдельной процедуры симулятора. Однако отметим, что при этом уже достаточно сложно становится отслеживать, что приложение выполняет на макроскопическом, алгоритмическом уровне, с которого мы начали наше рассмотрение.

Как и симуляция, виртуализация основывается на принципе замены реализаций алгоритмов используемой вычислительной системы начиная с некоторого слоя абстракции. Однако при этом акцент делается на обеспечение следующих двух свойств гостевых систем: их изолированности от хозяина и друг от друга и разделения (совместного использования) хозяйских ресурсов, таких как оперативная память, процессорное время, дисковое пространство и т.д. (рис.~\ref{fig:multiplexing}).

\begin{figure}[htb]
    \centering
%     \includegraphics[width=\textwidth]{./multiplexing-crop.pdf}
	% The first pyramid, three steps
	\begin{tikzpicture}[scale=0.9]
	\coordinate (A) at (-3.5,-3) {};
	\coordinate (B) at ( 3.5,-3) {};
	\coordinate (C) at ( 0, 0) {};
	\draw (A) -- ($(A)!3/4!(C)$);
	\draw (B) -- ($(B)!3/4!(C)$);
	\draw ($(A)!3/4!(C)$) -- ($(B)!3/4!(C)$);
        \foreach \y/\A in {0/{Аппаратные ресурсы},
						   1/{Инструкции},
						   2/{\scriptsize Вирт. машина 1}
						   } {
			\draw ($(A)!\y/4!(C)$) -- ($(B)!\y/4!(C)$)
			node[midway,above] {\footnotesize\A};
		};

	% The second pyramid, only one step
	% Copy-pasted from the first one and shifted
	\coordinate (D) at (7-3.5,-3) {};
	\coordinate (E) at (7+3.5,-3) {};
	\coordinate (F) at (7,     0) {};
	\draw ($(D)!2/4!(F)$) -- ($(D)!3/4!(F)$);
	\draw ($(E)!2/4!(F)$) -- ($(E)!3/4!(F)$);
	\draw ($(D)!3/4!(F)$) -- ($(E)!3/4!(F)$);
        \foreach \y/\A in {2/{\scriptsize Вирт. машина 2}
						   } {
			\draw ($(D)!\y/4!(F)$) -- ($(E)!\y/4!(F)$)
			node[midway,above] {\footnotesize\A};
		}
	
	% The multiplexing "arrow"
	\node [ arrow box, draw, arrow box arrows={east:.25cm, west:0.25cm}] at (3.5,-1.1) {\scriptsize Мультиплексирование}; 
		
	\end{tikzpicture}
    \caption[Виртуализация как сочетание изоляции и разделения ресурсов]{Виртуализация как сочетание изоляции виртуальных машин и разделения хозяйских ресурсов между ними. Под мультиплексированием понимается временн\'{o}е разделение выполнения нескольких виртуальных процессоров на одном хозяйском}
    \label{fig:multiplexing}
\end{figure}

Таким образом, почти любой симулятор является виртуальной машиной, потому что он обеспечивает изоляцию (при условии, что реализован корректно), а несколько его копий, запущенные одновременно, обеспечат разделение ресурсов. Монитор виртуальных машин не обязательно является симулятором в том смысле, что архитектура систем гостя и хозяина могут совпадать (т.е. симуляция при этом <<тривиальна>>, однако в главе~\ref{chapter04} показывается, что этот случай не так прост); разделение ресурсов при виртуализации, как правило, более эффективно, и она обеспечивает меньшие накладные расходы.

В заключение отметим, что предложенная выше классификация допускает возможность присутствия симулятора более чем на одном уровне абстракции. Например, модели уровня приложения могут эмулировать не только системные вызовы, но также некоторые инструкции, а функциональный симулятор может включать модель кэша. В этом случае граница между гостем и хозяином становится несколько размытой.

\section{История использования симуляции}

В различных формах компьютерные симуляторы используются с зари возникновения вычислительной техники. Так, IBM System/360 Model 67 выпуска 1967 года поддерживала виртуальные машины на аппаратном уровне~\cite{ibm360vm}, а саму System/360 эмулировали многие последующие ЭВМ, такие как RCA Spectra/70.

Приведём лишь несколько примеров использования симуляторов на ранних стадиях разработки новых архитектур и для обеспечения совместимости с существующим кодом.

\begin{itemize*}

\item Интересным примером использования симуляции для обеспечения обратной совместимости является продукция компании Apple.  Первые компьютеры Machintosh (1980-е гг.) были построены на процессорах Motorola 68x0 (общее название для серии чипов). В 1994 году новые компьютеры Apple стали использовать процессоры PowerPC. Для обеспечения работы приложений, написанных для старого оборудования, с ними поставлялся эмулятор~\cite{apple-ppcsoftware}, работа которого была максимально прозрачна для пользователя и приложений. В 2006 году произошёл ещё один переход --- на архитектуру Intel\textregistered IA-32. И снова для совместимости новые Макинтоши имели встроенный эмулятор с именем Rosetta \cite{apple-rosetta, macosx-internals}.

\item В 2001 году для новой архитектуры Intel\textregistered~ Itanium\texttrademark~ был использован симулятор Gambit~\cite{carole2001}.

\item В 2001 году для портирования операционной системы NetBSD на тогда ещё официально не выпущенную архитектуру AMD64 был использован симулятор Virtutech Simics~\cite{netbsd-amd64}.

\item В современных компьютерных системах часто используются подсистемы, предназначенные для обеспечения совместимости с устаревшим ПО и фактически являющиеся своеобразными симуляторами.

\item Во всех 32-битных ОС Microsoft Windows серии NT существует система NTVDM~\cite{ntvdm} --- эмулятор 16-битного режима MS-DOS. Отметим, что в 64-битных редакциях Windows по ряду причин технического характера подобного слоя совместимости нет. В свою очередь, запуск 32-битных приложений в 64-битных вариантах также требует создания специального окружения, отличного от того, в котором исполняются <<родные>> приложения~\cite[глава 3]{wininternals6-pt1}.

\item В некоторых версиях Microsoft Windows 7 (Professional, Ultimate и Enterprise) доступен режим совместимости с Microsoft Windows XP~\cite{winxp-mode}, выполненный в виде предустановленной в Virtual PC операционной системы, взаимодействие с которой производится по протоколу RDP.

\item Для архитектуры Intel\textregistered~ Itanium\texttrademark~ существует система совместимости для запуска кода архитектуры IA-32~\cite{Baraz03ia-32execution}, активно задействующая технологии статической и динамической двоичной трансляции (см. главу~\ref{chapter04}).

\item В 2012 году компания ARM объявила о введении нового 64-битного расширения своей архитектуры ARMv8. Первые образцы реальных процессоров ожидаются в 2013 году, до этого момента разработка и адаптация существующего кода может проводиться на симуляторе~\cite{armv8}.
\end{itemize*}

\section{Обзор существующих симуляторов и~виртуальных машин}\label{sec:implementations}

\begin{description*}

\item [VMware ESX(i) Server]~\cite{vmware-esx}. Коммерческий продукт, являющийся монитором первого типа.  Предназначен для виртуализации крупных систем уровня предприятия. VMware ESXi Server доступен бесплатно, тогда как VMware ESX Server требует коммерческой лицензии и предоставляет расширенные возможности.

\item [VMware Workstation] Проприетарный продукт, являющийся монитором виртуальных машин второго типа. Работает на операционных системах Windows и Linux. Бесплатный вариант для некоммерческого использования называется VMware Player.

\item[Xen]

Открытый монитор виртуальных машин первого типа, развиваемый компанией Citrix~\cite{xen2006}. Работает на большом числе хозяйских архитектур, включая ARM и IA-32. Применяется для крупномасштабной виртуализации (используется, например, компанией Amazon в облачном сервисе Amazon Elastic Compute Cloud). 

\item[Qemu]

Открытый симулятор различных систем~\cite{qemu}. Портирован для большого числа операционных систем.
В качестве гостевых архитектур поддерживает системы IA-32, IA-32 EMT64, IA-64, PowerPC, Alpha, SPARC 32/64, ARM\dots; в качестве хозяйских систем могут использоваться IA-32, IA-32 EMT64, ARM, CRIS, LM32, MicroBlaze, MIPS, SPARC 32/64, PowerPC. 

\item[KVM] (\abbr Kernel-based Virtual Machine). Открытый монитор виртуальных машин второго типа, основанный на технологиях Qemu и встроенный в ядро операционной системы Linux~\cite{kvm-wiki}. Популярен для задач виртуализации Linux и развивается фирмой Red Hat.

\item[Oracle VirtualBox]

Открытый монитор виртуальных машин второго типа~\cite{virtualbox} для гостевых и хозяйских архитектур IA-32 и портирован для работы внутри Windows, Linux, Mac OS X и других операционных системах. Является весьма популярным решением для <<домашней>> пользовательской виртуализации. Разрабатывается компанией Oracle.

\item[Bochs]

Открытый монитор виртуальных машин второго типа~\cite{bochs}. Работает на Windows, Linux, Mac OS X и других операционных системах. Является популярным решением для поддержки выполнения программ, скомпилированных для IA-32, на архитектурах, отличных от IA-32.

\end{description*}

\section{Производительность симуляции}

Любая модель должна описывать изучаемый объект с точностью, достаточной для нужд исследования. В случае компьютерной симуляции не менее важным фактором становится темп протекания процесса исследования --- \textbf{скорость симуляции}. С одной стороны, она напрямую зависит от быстродействия хозяйской системы, на которой запущена программа. С другой стороны, важно то, насколько оптимизирован сам симулятор для того, чтобы использовать весь предлагаемый аппаратурой потенциал. Наконец, скорость критическим образом зависит от самого сценария симуляции, т.е. какие гостевые приложения запущены и насколько требовательны они к ресурсам гостевой системы, особенно к наиболее сложно виртуализуемым их классам, например, высокоскоростным периферийным устройствам. Другими словами, практически для любого симулятора можно найти <<плохой>> гостевой код, при симуляции которого скорость будет очень низкой. Отметим, что запуск такого приложения на реальной системе в большинстве случаев также покажет невысокую производительность.

\subsection{Способы определения скорости}

Скорость симуляции, понимаемая как темп изменения значения виртуального времени, является первичной метрикой. Однако молниеносно пролетающие виртуальные секунды ещё не означают, что гостевые приложения эффективно его используют. 

Второй метрикой является демонстрируемая гостевым программным обеспечением скорость работы. Единицей измерения при этом выступает IPS (\abbr instructions per second). Однако важно при этом понимать, что для учёта влияния симуляции на скорость эта величина равна среднему числу \emph{гостевых} инструкций, исполняемых за одну \emph{хозяйскую} секунду. Чаще всего используют более крупные единицы, например, миллионы инструкций в секунду --- MIPS.

Следующая используемая на практике величина для характеризации производительности --- отношение времени работы интересующей исследователя программы внутри модели к длительности её исполнения <<снаружи>>, на идентичной хозяйской системе. В случае тождественности архитектур гостя и хозяина эта величина почти всегда больше единицы (внутри симулятора программа работает дольше), поэтому она получила название \textbf{накладные расходы, вызванные виртуализацией} (\abbr simulation overhead). 

Для приложений, производящих большое количество вычислений (например, задачи математического моделирования, решение задач уравнений математической физики и т.п.), применяется также другая метрика --- \textbf{FLOPS} (\abbr floating point operations per second), определяющая количество операций над числами с плавающей запятой (\abbr floating point number), совершаемых за одну секунду. Допустимые форматы таких чисел (т.н. одинарная, двойная точность и т.п.) определяются стандартом IEEE 754-2008~\cite{ieee754}.

\subsection[Соотношение скоростей]{Соотношение скоростей симулируемого и~реального времени}

Рассмотрим три варианта, как могут соотноситься скорости течения времени внутри (гостевое, симулируемое время) и снаружи (реальное, абсолютное время) симулятора.

\begin{enumerate*}

\item \textit{Симулируемое время течёт медленнее реального.} Этот случай очень часто встречается  на практике из-за необходимости программной реализации всех алгоритмов и механизмов, в реальной аппаратуре воплощённых «в железе». Так, существующие модели требуют исполнения от десятков до тысяч или более инструкций для симуляции одной. Другой пример --- моделирование двухпроцессорной системы на однопроцессорной требует как минимум в два раза больше реального времени. 

\item \textit{Симуляция быстрее реальности.} Такая ситуация также встречается на практике. Например, на процессоре с частотой 1 ГГц моделируется похожий процессор с частотой 10 МГц. При достаточно эффективной схеме работы может получиться, что модель будет работать в 10---100 раз быстрее, чем она работала бы в реальности. Другая ситуация --- использование гиперсимуляции, при которой модель быстро продвигает время вперёд, не изменяя состояния, тогда как реальная аппаратура «честно» выполнила бы все циклы. Столь быстрое исполнение не всегда желаемо, например, при взаимодействии с пользователем вводимые клавиши будут нажиматься очень быстро, и человек не успеет прореагировать. В таких случаях достаточно легко снизить скорость симуляции с помощью пауз абсолютного времени, искусственно вставляемых между исполнениями устройств. 

\item \textit{Темп симуляции равен (или почти равен) темпу течения физического времени} Как правило, это необходимо в интерактивных системах, зависящих от ввода пользователя,  например учебная или игровая симуляция управления автомобилем, самолётом. Для обеспечения такого режима необходимо специально следить за тем, чтобы скорость исполнения модели выдерживалась в определённых рамках, тогда как искусственно замедлить её относительно легко, ускорить исполнение зачастую непросто; возможное решение --- использования более простых моделей, дающих меньшую, но приемлемую точность состояния системы по сравнению с тем, что мы имели бы в реальности. Для описанного выше примера это может быть связано с уменьшением числа кадров в секунду, точности прорисовки деталей, «затуманиванием» удалённого пространства и т.д. В задачах симуляции ЭВМ понижение точности исполнения инструкций или  поведения устройств недопустимо, поэтому для них требование исполнения в реальном времени ставится очень редко.
\end{enumerate*}


\iftoggle{hasquiz}{
	\input{chapter01-questions}
}{}

\iftoggle{webpaper}{
    \printbibliography[title={Литература}]
}{}
