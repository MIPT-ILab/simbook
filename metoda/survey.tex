\chapter{Обзор существующих симуляторов и виртуальных машин}\label{survey}

\dictum[quote]{quote}


Перечислим некоторые способы практического применения программных моделей.

\begin{description*}
    
\item[Раннее обнаружение ошибок проектирования.] Программирование --- процесс значительно менее затратный, чем испытания реального железа, и что куда важнее, исправление ошибки в программе занимает минуты, тогда как повторный выпуск опытного образца аппаратуры может занять месяцы. 

\item[Написание сопутствующего аппаратуре ПО.] Ранняя доступность модели устройства позволяет использовать её для разработки драйверов, прошивок (таких как BIOS и UEFI~\cite{uefi-itj}) и даже операционных систем и компиляторов параллельно с разработкой самого устройства. В наше время нередка ситуация, что драйвера для нового оборудования готовы и отлажены ещё до официальной доступности предназначенного для них оборудования.

\item[Построение и исследование экспериментальных решений.] Моделирование позволяет быстрее и дешевле  изучать пространство проектирования (\abbr design space) для определения параметров, при которых устройство или система будет иметь наилучшие характеристики. Для исследователей интерес часто представляют количественные характеристики новых систем, такие как скорость работы, степень загруженности подсистем, потребление энергии и т.п. Иногда подобный анализ можно провести и без симуляции, используя аналитические методики, теорию массового обслуживания, экстраполяцию измерений на существующей аппаратуре и т.д. Однако моделирование даёт наибольшую гибкость.

\item[Качественно-функциональные свойства.] Под этим тер\-ми\-ном понимается изучение, работает или нет новая технология в принципе, безотносительно её скоростных характеристик. В этом случае альтернатив симуляции практически не остаётся, поскольку необходимо изучить функционирование системы.

\item[Выполнение программ на <<неродной>> архитектуре.] В этом случае модель обеспечивает прослойку, позволяющую выполнять приложения без перекомпиляции на машинах, изначально не предназначенных для исполнения этих программ. 

\end{description*}


\begin{description*}

\item[Эмулятор] (\abbr emulator) --- программа, моделирующая некоторую физическую систему путём имитации внутренней структуры и процессов, происходящих внутри подсистем аппаратуры.

\item[Симулятор] (\abbr simulator) --- программа, моделирующая некоторую физическую систему через предоставление корректных интерфейсов входящих в неё подсистем и обеспечивающая правильное их функционирование, но не гарантирующая того, что их внутреннее устройство будет похоже на устройство аналогичных подсистем реального компьютера (т.е. работающая как <<чёрный ящик>>). 

Следует отметить, что разница в определениях симулятора и эмулятора размыта, поэтому мы будем считать оба термина эквивалентными.

\item[Хозяин] (\abbr host) ---  физическая вычислительная система, на которой исполняются программы, в том числе моделирующие другие вычислительные системы. При этом потребляются хозяйские ресурсы (процессорное время, память, электроэнергия и т.п.). Также в литературе встречается синонимичный термин \textit{инструментальная система}.

\item[Гость] (\abbr guest) ---  система, поведение которой призван отражать симулятор и внутри которой исполняются гостевые приложения. Синонимичным является понятие \textit{целевая система} (\abbr target system).

\item[Виртуализация] (\abbr virtualization) --- выполнение одной или более гостевых программ, в т.ч. операционных систем, внутри изолированных друг от друга окружений. При этом управляющая программа, в данном случае называемая \textit{гипервизором} (\abbr hypervisor) или монитором виртуальных машин (\abbr virtual machine monitor, VMM), контролирует доступ виртуализованных приложений к физическим ресурсам системы.  В главе~\ref{virt} рассматриваются теоретические и практические аспекты виртуализации. Сейчас же определим два основных типа гипервизоров.

\item[Гипервизоры первого типа] (автономные гипервизоры) работают прямо на хозяйской аппаратуре, т.е. не требуют для своей работы операционной системы, они берут её функции на себя и являются привилегированными приложениями. Данное обстоятельство позволяет минимизировать накладные расходы виртуализации. Вместе с тем при разработке автономного монитора приходится тратить много усилий на поддержку в нём функций операционной системы. На рис.~\ref{fig:vm-type1} приведён пример взаимного расположения программных компонент при использовании гипервизора первого типа.

\begin{figure}[htp]
\centering
\inputpicture{drawings/vm-type1}
\caption[Гипервизор первого типа]{Пример использования гипервизора первого типа для одновременного запуска приложений двух различных операционных систем}\label{fig:vm-type1}
\end{figure}

Примеры существующих мониторов виртуальных машин первого типа: VMware ESX(i) Server~\cite{vmware-esx}, Xen~\cite{xen2006}.

\item[Гипервизоры второго типа] не заменяют операционную систему, но работают поверх неё как обычное пользовательское приложение (рис.~\ref{fig:vm-type2}), иногда требуя установки драйверов или модулей ядра, работающих с повышенным приоритетом. Примеры таких программных продуктов: Oracle VirtualBox~\cite{virtualbox}, KVM~\cite{kvm-wiki} (\abbr kernel-based virtual machine). Накладные расходы на виртуализацию при их работе выше, чем при использовании мониторов первого типа.

\begin{figure}[htp]
    \centering
	\inputpicture{drawings/vm-type2}
    \caption[Гипервизор второго типа]{Пример использования гипервизора второго типа для запуска приложений второй операционной системы при уже загруженной основной}\label{fig:vm-type2}
\end{figure}

\item[Полноплатформенный симулятор] (\abbr full platform si\-mu\-la\-tor) --- модель, включающая в себя компоненты, достаточные для получения поведения некоторого компьютера в целом, т.е. состоящая как минимум из следующих основных устройств: процессора, памяти, дискового устройства, сетевого устройства, клавиатуры, мыши, монитора и др. Внутри такого симулятора возможно запустить немодифицированную операционную систему, и она будет работать так же, как работала бы на реальной аппаратуре.

\item[Симулятор режима приложения] (\abbr application mode si\-mu\-la\-tor) --- программа, предназначенная для запуска <<обычных>> прикладных приложений (т.е. не операционных систем, BIOS или другого системного ПО). Целевые программы при этом ожидают активного присутствия определённой операционной системы, и потому симулятор обязан в том числе эмулировать необходимые  системные вызовы для того, чтобы создать окружение, неотличимое от предоставляемого операционной системой. При этом модель получается жёстко привязанной к конкретному варианту системного ПО, так как список и формат системных вызовов и прочих интерфейсов приложений может заметно меняться между ОС (например, Windows, Linux и Mac OS имеют разные механизмы вызова операций в контексте ОС) и даже внутри одной ОС между её версиями (например, Linux 2.4 и Linux 2.6). Как правило, количество моделируемого при этом аппаратного обеспечения минимально.

\item[Функциональная модель] (\abbr functional model) --- симулятор, точность которого ограничена корректной функциональностью целевых приложений без обеспечения правильных значений длительностей операций, наблюдаемых в реальности. Например, доступ к памяти возвращает правильное значение, но за один такт моделируемого времени, тогда как в реальности он занял бы от 20 до 100 тактов в зависимости от состояния системы кэшей. Подобные модели недостаточно точны для предсказания производительности, но, как правило, достаточны для корректной работы большинства гостевого ПО, включая операционные системы, так как алгоритмы отдельных инструкций соответствуют реальности.

\item[Потактовая модель] (\abbr cycle precise model, performance model)  --- симулятор, корректно высчитывающий ход времени внутри моделируемой системы. Он моделирует её внутреннее устройство более детально, чем это делается в функциональных моделях. Потактовые модели обычно во много раз медленнее функциональных.

\item[Гибридная модель] (\abbr hybrid model) --- система симуляции, частично реализованная в программе для классического, обычного компьютера, а частично --- на специализированном оборудовании (например, на ПЛИС\footnote{Программируемая логическая интегральная схема.}). Применяется в тех случаях, когда чисто программное моделирующее решение недостаточно быстро.

\end{description*}


\section{История использования симуляции}

В различных формах компьютерные симуляторы используются с зари возникновения вычислительной техники. Так, IBM System/360 Model 67 выпуска 1967 года поддерживала виртуальные машины на аппаратном уровне~\cite{ibm360vm}, а саму System/360 эмулировали многие последующие поколения аппаратуры, такие как RCA Spectra/70.

\begin{itemize*}

\item Интересным примером использования симуляции для обеспечения обратной совместимости является продукция компании Apple.  Первые компьютеры Machintosh (1980-е гг.) были построены на процессорах Motorola 68x0 (общее название для серии чипов). В 1994 году новые компьютеры Apple стали использовать процессоры PowerPC. Для обеспечения работы приложений, написанных для старого оборудования, с ними поставлялся эмулятор~\cite{apple-ppcsoftware}, работа которого была максимально прозрачна для пользователя и приложений. В 2006 году произошёл ещё один переход --- на архитектуру Intel\textregistered~~IA-32. И снова для совместимости новые Макинтоши имели встроенный эмулятор с именем Rosetta \cite{apple-rosetta, macosx-internals}.

\item В 2001 году для новой архитектуры Intel\textregistered~ Itanium\texttrademark~ был использован симулятор SoftSDV~\cite{softsdv-ia64}.

\item В 2001 году для портирования операционной системы NetBSD на тогда ещё официально не выпущенную архитектуру AMD64 был использован симулятор Virtutech Simics~\cite{netbsd-amd64}.

\item В современных компьютерных системах часто используются подсистемы, предназначенные для обеспечения совместимости с устаревшим ПО и фактически являющиеся своеобразными симуляторами.

\item Во всех 32-битных ОС Microsoft Windows серии NT существует система NTVDM~\cite{ntvdm} --- эмулятор 16-битного режима MS-DOS. Отметим, что в 64-битных редакциях Windows по ряду причин технического характера подобного слоя совместимости нет. В свою очередь, запуск 32-битных приложений в 64-битных вариантах также требует создания специального окружения, отличного от того, в котором исполняются <<родные>> приложения~\cite[глава 3]{wininternals6-pt1}.

\item В некоторых версиях Microsoft Windows 7 (Professional, Ultimate и Enterprise) доступен режим совместимости с Microsoft Windows XP~\cite{winxp-mode}, выполненный в виде предустановленной в Virtual PC операционной системы, взаимодействие с которой производится по сетевому протоколу RDP (\abbr remote desktop protocol).

\item Для архитектуры Intel\textregistered~ Itanium\texttrademark~ существует система совместимости для запуска кода архитектуры IA-32~\cite{Baraz03ia-32execution}, активно задействующая технологии статической и динамической двоичной трансляции (см. главу~\ref{bt}).

\item В 2012 году компания ARM объявила о введении нового 64-битного расширения своей архитектуры ARMv8. Первые образцы реальных процессоров ожидаются в 2013 году, до этого момента разработка и адаптация существующего кода может проводиться на симуляторе~\cite{armv8}.
\end{itemize*}

\section{Обзор существующих симуляторов и~виртуальных машин}\label{sec:implementations}

\begin{description*}

\item [VMware ESX(i) Server]~\cite{vmware-esx}. Коммерческий продукт, являющийся гипервизором первого типа.  Предназначен для виртуализации крупных систем уровня предприятия. VMware ESXi Server доступен бесплатно, тогда как VMware ESX Server требует коммерческой лицензии и предоставляет расширенные возможности.

\item [VMware Workstation] Проприетарный продукт, являющийся монитором виртуальных машин второго типа. Работает на операционных системах Windows и Linux. Бесплатный вариант для некоммерческого использования называется VMware Player.

\item[Xen]

Открытый монитор виртуальных машин первого типа, развиваемый компанией Citrix~\cite{xen2006}. Работает на большом числе хозяйских архитектур, включая ARM и IA-32. Применяется для крупномасштабной виртуализации (используется, например, компанией Amazon в облачном сервисе Amazon Elastic Compute Cloud). 

\item[Qemu]

Открытый симулятор различных систем~\cite{qemu}. Портирован для большого числа операционных систем.
В качестве гостевых архитектур поддерживает системы IA-32, IA-32 EMT64, IA-64, PowerPC, Alpha, SPARC 32/64, ARM\dots; в качестве хозяйских систем могут использоваться IA-32, IA-32 EMT64, ARM, CRIS, LM32, MicroBlaze, MIPS, SPARC 32/64, PowerPC. 

\item[KVM] (\abbr Kernel-based Virtual Machine). Открытый монитор виртуальных машин второго типа, основанный на технологиях Qemu и встроенный в ядро операционной системы Linux~\cite{kvm-wiki}. Популярен для задач виртуализации Linux и развивается фирмой Red Hat.

\item[Oracle VirtualBox]

Открытый монитор виртуальных машин второго типа~\cite{virtualbox} для гостевых и хозяйских архитектур IA-32 и портирован для работы внутри Windows, Linux, Mac OS X и других операционных системах. Является весьма популярным решением для <<домашней>> пользовательской виртуализации. Разрабатывается компанией Oracle.

\item[Bochs]

Открытый монитор виртуальных машин второго типа~\cite{bochs}. Работает на Windows, Linux, Mac OS X и других операционных системах. Является популярным решением для поддержки выполнения программ, скомпилированных для IA-32, на архитектурах, отличных от IA-32.

\end{description*}

Разработка программного обеспечения


Wind River Simics
Intel SDE
SoftSDV
OVPsim

SystemC-based

Исследование производительности

PTLSim

Graphite



Виртуализация ресурсов

KVM
Xen
Vmware ESX, Player,
VirtualBox 
HyperV

Обеспечение соместимости

Qemu,

Bochs,

Wine

NTVDM.

Digital FX!

IA32 EL

VirtualPC

MAME MESS

FECUX, DosBox

PCE
http://www.hampa.ch/pce/about.html

Экспериментальные

JS BOX,
Javascript
IOCCC 8086




% \input{survey-questions}

\iftoggle{webpaper}{
    \printbibliography[title={Литература}]
}{}

