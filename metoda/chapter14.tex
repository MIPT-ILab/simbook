\chapter{Современная виртуализация}\label{chapter14}

\dictum[Harlan McGhan]{When this sort of deliberate disconnection from reality happens with people, it generally goes by names like deceit, fraud, misrepresentation, or simply lying. When it happens with computers, it’s called virtualization.}

\section{Введение}

Для понимания того, каким образом современные вычислительные системы, их новые свойства, инструкции и режимы призваны поддерживать виртуализацию, в этой главе мы рассмотрим теоретические основания возможности её \textbf{эффективной} реализации. 

Виртуализация представляла интерес ещё до изобретения микропроцессора, во времена преобладания больших систем --- мейэнфреймов, ресурсы которых были очень дорогими, и их простой был экономически недопустим. Виртуализация позволяла повысить степень утилизации таких систем, при этом избавив пользователей и прикладных программистов от необходимости переписывать своё ПО, так как с их точки зрения виртуальная машина была идентична физической. Пионером в этой области являлась фирма IBM с мэйнфреймами System/360, System/370, созданными в 1960--1970-х гг.

\section{Классический критерий виртуализуемости}

Неудивительно, что критерии возможности создания эффективного монитора виртуальных машин были получены примерно в то же время. Они сформулированы в классической работе 1974 г. Жеральда Попека  и Роберта Голдберга <<Formal requirements for virtualizable third generation architectures>>~\cite{popek}. Рассмотрим её основные предпосылки и сформулируем её основной вывод.

\subsection{Модель системы}

В дальнейшем используется упрощённое представление <<стандартной>> ЭВМ, состоящей из (одного) центрального процессора и линейной однородной оперативной памяти. Периферийные устройства, а также средства взаимодействия с ними опускаются. Процессор поддерживает два режима работы: режим супервизора, используемый операционной системой, и режим пользователя, в котором исполняются прикладные приложения. Память поддерживает режим сегментации, используемый для организации виртуальной памяти.

Выдвигаемые требования на монитор виртуальных машин (ВМ): 

\begin{description*}

\item[Изоляция] --- каждая виртуальная машина должна иметь доступ только к тем ресурсам, которые были ей назначены. Она не должна иметь возможности повлиять на работы как монитора, так и других ВМ.

\item[Эквивалентность] --- любая программа, исполняемая под управлением ВМ, должна демонстрировать поведение, полностью идентичное её исполнению на реальной системе, \emph{за исключением} эффектов, вызванных двумя обстоятельствами: различием в количестве доступных ресурсов (например, ВМ может иметь меньший объём памяти) и длительностями операций (из-за возможности разделения времени исполнения с другими ВМ).

Отметим, что для симуляторов в общем смысле эквивалентность не является требованием, т.к. в случаях, когда хозяйская и гостевая архитектуры не совпадают, поведение гостя и хозяина различаются.

\item[Эффективность] --- в оригинальной работе условие сформулировано следующим образом: <<статистически преобладающее подмножество инструкций виртуального процессора должно исполняться напрямую хозяйским процессором, без вмешательства монитора ВМ>>. Другими словами, значительная часть инструкций должна симулироваться в режиме прямого исполнения. Требование эффективности является самым неоднозначным из трёх перечисленных требований, и мы вернёмся к нему в секции~\ref{sec:revising-efficiency}.

В случае симуляторов, основанных на интерпретации инструкций, условие эффективности не выполняется, т.к. каждая инструкция гостя требует обработки симулятором.

\end{description*}

\subsection{Классы инструкций}

Состояние процессора содержит минимум три регистра: $M$, определяющий, находится ли он в режиме супервизора $s$ или пользователя $u$, $P$ --- указатель текущей инструкции и $R$ --- состояние, определяющее границы текущего сегмента памяти\footnote{В простейшем случае $R=(l,b)$, где $l$ --- адрес начала диапазона, $b$ --- его длина.}. При исполнении каждая инструкция $i$ в общем случае может изменить как $(M,P,R)$, так и память $E$, т.е. она является функцией преобразования 

$$(M_1,P_1,R_1,E_1) \overset{i}\mapsto (M_2,P_2,R_2,E_2).$$ 

Память $E$ состоит из фиксированного числа ячеек, к которым можно обращаться по их номеру $t$, например, $E[t]$. Размер памяти и ячеек для данного рассмотрения несущественен.

Считается, что для некоторых входных условий инструкция вызывает исключение \textbf{ловушки} (\abbr trap), если в результате её исполнения содержимое памяти не изменяется, кроме единственной ячейки $E[0]$, в которую  помещается предыдущее состояние процессора $(M_1,P_1,R_1)$. Новое состояние процессора $(M_2,P_2,R_2)$ при этом копируется из $E[1]$. Другими словами, ловушка позволяет сохранить полное состояние программы на момент до начала исполнения её последней инструкции и передать управление обработчику, в случае обычных систем обычно работающему в режиме супервизора и призванного обеспечить дополнительные действия над состоянием системы, а затем вернуть управление в программу, восстановив состояние из $E[0]$.

Далее, ловушки могут иметь два признака.
\begin{enumerate*}
\item Вызванные попыткой изменить состояние процессора (ловушка \textbf{потока управления}).

\item Обращения к содержимому памяти, выходящему за пределы диапазона, определённого в $R$ (ловушка \textbf{защиты памяти}). 
\end{enumerate*}

Отметим, что эти признаки не взаимоисключающие. То есть результатом исполнения могут быть одновременно ловушка потока управления и защиты памяти.

Машинные инструкции рассматриваемого процессора можно классифицировать следующим образом:

\begin{description*}
\item[Привилегированные (\abbr privileged).] Инструкции, исполнение которых с $M = u$ всегда вызывает ловушку потока управления. Другими словами, такая инструкция может исполняться только в режиме супервизора, иначе она обязательно вызывает исключение.

\item[Служебные (\abbr sensitive\footnotemark).]\footnotetext{Установившего русского термина для этого понятия нет. Иногда в литературе встречается перевод <<чувствительные>> инструкции.} Класс состоит из двух подклассов. 1. Инструкции, исполнение которых закончилось без ловушки защиты памяти и вызвало изменение $M$ и/или $R$. Они могут менять режим процессора из супервизора в пользовательский или обратно или изменять положение и размер доступного сегмента памяти. 2. Инструкции, поведение которых в случаях, когда они не вызывают ловушку защиты памяти, зависят или от режима $M$, или от значения $R$.

\item[Безвредные (\abbr innocuous).] Не являющиеся служебными. Самый широкий класс инструкций, не манипулирующие ничем, кроме указателя инструкций $P$ и памяти $E$, поведение которых не зависит от того, в каком режиме или с каким адресом в памяти они расположены.

\end{description*}

\subsection[Достаточное условие]{Достаточное условие построения монитора ВМ} 

Соблюдение трёх сформулированных выше условий возможности построения монитора виртуальных машин даётся в следующем предложении: \textbf{множество служебных инструкций является подмножеством привилегированных инструкций} (рис.~\ref{fig:vm-sufficient-condition}). Опуская формальное доказательство теоремы 1 из статьи, отметим следующие обстоятельства.

\begin{itemize*}
    \item Изоляция обеспечивается размещением монитора в режиме супервизора, а ВМ --- только в пользовательском. При этом последние не могут самовольно изменить системные ресурсы $(M,R)$ --- попытка вызовет ловушку потока управления на служебной инструкции и переход в монитор, а также память $E[0,1]$ из-за того, что конфигурация $R$ не допускает этого, и процессор выполнит ловушку защиты памяти.
    \item Эквивалентность доказывается тем, что безвредные инструкции выполняются одинаково вне зависимости от того, присутствует ли в системе монитор или нет, а служебные всегда вызывают исключение и интерпретируются. Отметим, что даже в описанной выше простой схеме проявляется первое ослабляющее условие: даже без учёта памяти, необходимой для хранения кода и данных гипервизора, объём доступной для ВМ памяти будет как минимум на две ячейки меньше, чем имеется у хозяйской системы.
    \item Эффективность гарантируется тем, что все безвредные инструкции внутри ВМ исполняются напрямую, без замедления. При этом подразумевается, что их множество включает в себя <<статистически преобладающее подмножество инструкций виртуального процессора>>.
\end{itemize*}

\begin{figure}[htb]
    \centering
    % \includegraphics[width=0.6\textwidth]{./vm-sufficient-condition-crop}
\begin{tikzpicture}[font=\small]
    \fill[draw, fill=black!20] (0,0) circle [x radius=2.5cm, y radius=1.5cm];
    \fill[draw, fill=black!10] (4.5,0) circle [x radius=2cm, y radius=1.5cm];
    \node[fill=white, inner sep=1pt] at (0.0,0.75) {Привилегированные};
    \node[fill=white, inner sep=1pt] at (4.5,0.75) {Безобидные};
    
    \fill[draw, fill=white] (0,-0.75) circle [x radius=1.2cm, y radius=0.75cm];
    \node[fill=white, inner sep=1pt] at (0,-0.75) {Служебные};
\end{tikzpicture}
    \caption[Выполнение условия виртуализуемости]{Выполнение условия виртуализуемости. Множество служебных инструкций является подмножеством привилегированных}
    \label{fig:vm-sufficient-condition}
\end{figure}

\section{Ограничения применимости критерия виртуализуемости}\label{sec:revising-efficiency}

Несмотря на простоту использованной модели и полученных из неё выводов, работа Голдберга и Попека является актуальной до сих пор. Следует отметить, что несоблюдение описанных в ней условий вовсе не делает создание или использование виртуальных машин на некоторой архитектуре принципиально невозможным, и есть практические примеры реализаций, подтверждающие это. Однако соблюсти оптимальный баланс между тремя свойствами: изоляцией, эквивалентностью и эффективностью, --- становится невозможным. Чаще всего расплачиваться приходится скоростью работы виртуальных машин из-за необходимости тщательного поиска и программного контроля за исполнением ими служебных, но не привилегированных инструкций, так как сама аппаратура не обеспечивает этого (рис.~\ref{fig:vm-bad-condition}). Даже единственная такая инструкция, исполненная напрямую ВМ, угрожает стабильной работе монитора, и поэтому он вынужден сканировать весь поток гостевых инструкций.

\begin{figure}[htb]
    \centering
    % \includegraphics[width=0.6\textwidth]{./vm-bad-condition-crop}
\begin{tikzpicture}[font=\small]
    \fill[draw, fill=black!5] (0,0) circle [x radius=2.5cm, y radius=1.5cm];
    \fill[draw, fill=black!10] (4.5,0) circle [x radius=2cm, y radius=1.5cm];
    \node[fill=white, inner sep=1pt] at (0.0,0.75) {Привилегированные};
    \node[fill=white, inner sep=1pt] at (4.5,0.75) {Безобидные};
    \fill[fill=black!20] (1.5,-0.75) circle [x radius=1.2cm, y radius=0.75cm] coordinate (service);
    \begin{scope}
        \clip[draw] (1.5,-0.75) circle [x radius=1.2cm, y radius=0.75cm];
        \fill[draw, fill=white] (0,0) circle [x radius=2.5cm, y radius=1.5cm];
    \end{scope}
    \node[fill=white, inner sep=0pt] at (service) {Служебные};
\end{tikzpicture}
    \caption[Невыполнение условия виртуализуемости]{Невыполнение условия виртуализуемости. Служебные, но не привилегированные инструкции требуют реализации сложной логики в мониторе}
    \label{fig:vm-bad-condition}
\end{figure}

В самой работе~\cite{popek} присутствуют как явно указанные упрощения исследуемой структуры реальных систем (отсутствие периферии и системы ввода-вывода), так и неявные предположения о структуре исполняемых гостевых программ (почти полностью состоящих из безвредных инструкций) и хозяйских систем (однопроцессорность).

Рассмотрим теперь данные ограничения более детально, а также предложим, каким образом можно расширить степень применимости критерия к дополнительным ресурсам, требующим виртуализации, и таким образом повысить его практическую ценность для архитекторов новых вычислительных систем.

\subsection{Структура гостевых программ}

Для эффективной работы программ внутри ВМ необходимо, чтобы большая часть их инструкций являлись безвредными. Как правило, это верно для прикладных приложений. Операционные системы, в свою очередь, предназначены для управления ресурсами системы, что подразумевает использование ими привилегированных и служебных инструкций, и монитору приходится их перехватывать и интерпретировать с соответствующим падением производительности. Поэтому в идеале в наборе инструкций должно быть как можно меньше привилегированных для того, чтобы частота возникновения ловушек была минимальной.

\subsection{Периферия}

Поскольку периферийные устройства являются служебным ресурсом ЭВМ, очевидно, что для обеспечения условий изоляции и эквивалентности необходимо, чтобы все попытки доступа к ним были контролируемы монитором ВМ так же, как они контролируются в многозадачной операционной системе её ядром. В настоящее время доступ к устройствам чаще всего производится через механизм отражения их в физической памяти системы (\abbr memory mapped I/O), что означает, что внутри монитора это чтение/запись некоторых регионов должно или вызывать ловушку защиты памяти, или быть не служебным, т.е. не вызывать ловушку и не влиять на состояние неконтролируемым образом.

Интенсивность взаимодействия приложений с периферией может быть различна и определяется их функциональностью, что сказывается на их замедлении при виртуализации. Кроме того, монитор ВМ может делать различные классы периферии, присутствующей на хозяине, доступными внутри нескольких ВМ различными способами.

\begin{description*}
    \item[Выделенное устройство] --- устройство, доступное исключительно внутри одной гостевой системы. Примеры: клавиатура, монитор.
    \item[Разделяемое] --- общее для нескольких гостей. Такое устройство или имеет несколько частей, каждая из которых  выделена для нужд одного из них (\abbr partitioned mode), например, жёсткий диск с несколькими разделами, или подключается к каждому из них поочерёдно (\abbr shared mode). Пример: сетевая карта.
    \item[Полностью виртуальное] --- устройство, отсутствующее в реальной системе (или присутствующее, но в ограниченном количестве) и моделируемое программно внутри монитора. Примеры: таймеры прерываний --- каждый гость имеет собственный таймер, несмотря на то, что в хозяйской системе есть только один, и он используется для собственных нужд монитора.
\end{description*}


\subsection{Прерывания}

Прерывания являются механизмом оповещения процессора о событиях внешних устройств, требующих внимания операционной системы. В случае использования виртуальных машин монитор должен иметь возможность контролировать доставку прерываний, так как часть или все из них необходимо обрабатывать именно внутри монитора. Например, прерывание таймера может быть использовано им для отслеживания/ограничения использования гостями процессорного времени и для возможности переключения между несколькими одновременно запущенными ВМ. Кроме того, в случае нескольких гостей заранее неясно, какому из них следует доставить прерывание, и принять решение должен монитор.

Простейшее решение, обеспечивающее изоляцию, --- это направлять \textbf{все} прерывания в монитор ВМ. Эквивалентность при этом будет обеспечиваться им самим: прерывание при необходимости будет доставлено внутрь гостя через симуляцию изменения его состояния. Монитор может дополнительно создавать виртуальные прерывания, обусловленные только логикой его работы, а не внешними событиями. Однако эффективность такого решения не будет оптимальной. Как правило, реакция системы на прерывание должна произойти в течение ограниченного времени, иначе она потеряет смысл для внешнего устройства или будет иметь катастрофические последствия для системы в целом. Введение слоя виртуализации увеличивает задержку между моментом  возникновения события и моментом его обработки в госте по сравнению с системой без виртуализации. Более эффективным является аппаратный контроль за доставкой прерываний, позволяющий часть из них сделать безвредными для состояния системы и не требовать каждый раз вмешательства программы монитора.

\subsection{Многопроцессорные системы}

\subsubsection{Синхронизация и виртуализация}

Введение в рассмотрение нескольких хозяйских и гостевых процессоров оставляет условие эффективной виртуализуемости в силе. Однако необходимо обратить внимание на выполнение условий эффективности работы многопоточных приложений внутри ВМ. В отличие от однопоточных, для них характерны процессы синхронизации частей программы, исполняющихся на различных виртуальных процессорах. При этом все участвующие потоки ожидают, когда все они достигнут заранее определённой точки алгоритма, т.н. барьера. В случае виртуализации системы один или несколько гостевых потоков могуть оказаться неактивными, вытесненными монитором, из-за чего остальные будут попусту тратить время.

Примером такого неэффективного поведения гостевых систем является синхронизация с задействованием циклических блокировок (\abbr spin lock) внутри ВМ~\cite{southern-v12n}. Будучи неэффективной и поэтому неиспользуемой для однопроцессорных систем, в случае нескольких процессоров она является легковесной альтернативой классическим замкам (\abbr lock), используемым для входа в критические секции параллельных алгоритмов. Чаще всего они используются внутри операционной системы, но не пользовательских программ, так как только ОС может точно определить, какие из системных ресурсов могут быть эффективно защищены с помощью циклических блокировок. Однако в случае виртуальной машины планированием ресурсов занимается не ОС, а монитор ВМ, который в общем случае не осведомлён о них и может вытеснить поток, способный освободить ресурс, тогда как второй поток будет выполнять циклическую блокировку, бесполезно тратя процессорное время. Оптимальным решением при этом является деактивация заблокированного потока до тех пор, пока нужный ему ресурс не освободится.

Существующие решения для данной проблемы описанны ниже.

\begin{enumerate*}
    \item Монитор ВМ может пытаться детектировать использование циклических блокировок гостевой ОС. Это требует анализа кода перед исполнением, установки точек останова по адресам замка. Способ не отличается универсальностью и надёжностью детектирования.
    \item Гостевая система может сигнализировать монитору о намерении использовать циклическую блокировку с помощью специальной инструкции. Способ более надёжный, однако требующий модификации кода гостевой ОС.
\end{enumerate*}

\subsubsection{Прерывания в многопроцессорных системах}

Наконец, отметим, что схемы доставки и обработки прерываний в системах с несколькими процессорами также более сложны, и это приходится учитывать при создании монитора ВМ для таких систем, при этом его эффективность может оказаться ниже, чем у однопроцессорного эквивалента. 

\subsection{Преобразование адресов}

Модель машинных инструкций, использованная ранее для формулировки основного утверждения данной главы, использовала простую линейную схему трансляции адресов, основанную на сегментации, популярную в 70-х годах прошлого века. Она является вычислительно простой, не изменяется при введении монитора ВМ, и поэтому анализа влияния механизма преобразования адресов на эффективность не производилось.

В настоящее время механизмы страничной виртуальной памяти и применяют нелинейное преобразование виртуальных адресов пользовательских приложений в физические адреса, используемые аппаратурой. Участвующий при этом системный ресурс --- регистр-указатель адреса таблицы преобразований\footnote{Чаще всего на практике используется несколько таблиц, образующих иерархию, имеющую общий корень.}. В случае использования ВМ этот указатель необходимо виртуализовать, так как у каждой гостевой системы содержимое регистра своё, как и положение/содержимое таблицы. Стоимость программной реализации этого механизма внутри монитора высока, поэтому приложения, активно использующие память, могут терять в эффективности при виртуализации.

Для решения этой проблемы используется двухуровневая аппаратная трансляция адресов (рис.~\ref{fig:two-level-translation}). Гостевые ОС видят только первый уровень, тогда как генерируемый для них физический адрес в дальнейшем транслируется вторым уровнем в настоящий адрес.

\begin{figure}[htb]
    \centering
    % \includegraphics[width=0.75\textwidth]{./two-level-translation-crop}
\begin{tikzpicture}[>=latex, font=\scriptsize, scale=0.8]
    \foreach \x in {0,1} 
    {\foreach \y in {0,1,2,3,4,5,8,9,10,11,12,13} { % vertical offsets of two groups
			\node[draw, minimum width=1.2cm, minimum height=0.4cm, inner sep=0pt] at (\x*3.5cm, -\y * 0.6 cm) (vpage-\x-\y) {};
      };
    };
    
    \foreach \y in {0,1,2,3,4,5,6,7,8,9,10,11} {
			\node[draw, minimum width=1.2cm, minimum height=0.4cm, inner sep=0pt] at (7cm, -0.6cm -\y * 0.6 cm) (ppage-\y) {};
    };

    \node[draw, dashed, inner sep=0pt, fit=(vpage-0-0) (vpage-1-5) ]  (vm1-border) {} ;
    \node[draw, dashed,  inner sep=0pt, fit=(vpage-0-8) (vpage-1-13) ]  (vm2-border) {} ;
    \node[fill=white, inner sep=1pt] at (vm1-border.north) {Виртуальная машина 1};
    \node[fill=white, inner sep=1pt] at (vm2-border.north) {Виртуальная машина 2};
    
    \node[text width=3cm, below=0.5cm of vpage-0-13, align=flush left] {Виртуальные адреса приложений};
    \node[text width=3cm, below=0.5cm of vpage-1-13, align=flush left] {Физические адреса гостевых ОС};
    \node[text width=3cm, below=1.cm of ppage-11, align=flush left] {Настоящие физические адреса хозяина};
    
    \draw[->] (vpage-0-0.east) -- (vpage-1-3.west);
    \draw[->] (vpage-0-1.east) -- (vpage-1-2.west);
    \draw[->] (vpage-0-2.east) -- (vpage-1-1.west);
    \draw[->] (vpage-0-5.east) -- (vpage-1-0.west);
    \node[fill=white, rotate=90, text width=2.5cm, inner sep=0pt] at (1.75, -2*0.6) {Первый уровень преобразования адресов};
    
    \draw[->] (vpage-0-10.east) -- (vpage-1-8.west);
    \draw[->] (vpage-0-8.east) -- (vpage-1-10.west);
    \draw[->] (vpage-0-9.east) -- (vpage-1-10.west);
    \draw[->] (vpage-0-10.east) -- (vpage-1-12.west);
    \draw[->] (vpage-0-13.east) -- (vpage-1-13.west);
    \node[fill=white, rotate=90, text width=2.5cm, inner sep=0pt] at (1.75, -10*0.6) {Первый уровень преобразования адресов};
    
    \draw[->] (vpage-1-0.east) -- (ppage-9.west);
    \draw[->] (vpage-1-1.east) -- (ppage-5.west);
    \draw[->] (vpage-1-2.east) -- (ppage-3.west);
    \draw[->] (vpage-1-3.east) -- (ppage-1.west);
    
    \draw[->] (vpage-1-8.east) -- (ppage-0.west);
    \draw[->] (vpage-1-9.east) -- (ppage-10.west);
    \draw[->] (vpage-1-10.east) -- (ppage-11.west);
    \draw[->] (vpage-1-13.east) -- (ppage-11.west);
    \node[fill=white, rotate=90, inner sep=0pt] at (5.5, -7*0.6) {Второй уровень преобразования адресов};
\end{tikzpicture}
    \caption[Двухуровневая трансляция адресов]{Двухуровневая трансляция адресов. Первый уровень контролируется гостевыми ОС, второй --- монитором виртуальных машин}
    \label{fig:two-level-translation}
\end{figure}

\subsubsection{TLB}

Другой ресурс ЭВМ, отвечающий за преобразование адресов, --- это буфер ассоциативной трансляции (\abbr translation lookaside buffer, TLB), состоящий из нескольких записей. Каждая гостевая система имеет своё содержимое TLB, поэтому при смене активной ВМ или переходе в монитор он должен быть сброшен. Это негативно сказывается на производительности систем, так как восстановление его содержимого требует времени, в течение которого приходится использовать менее эффективное обращение к таблице трансляций, расположенной в памяти.

Решение состоит в разделении ресурсов TLB между всеми системами~\cite{YANG:2008}. Каждая строка буфера ассоциируется с идентификатором --- тэгом, уникальным для каждой ВМ. При поиске в нём аппаратурой учитываются только строки, тэг которых соответствует текущей ВМ.

\subsubsection{Преобразование адресов для периферийных устройств}

Кроме процессоров к оперативной памяти напрямую могут обращаться и периферийные устройства ---  с помощью технологии DMA (\abbr direct memory access). При этом обращения в классических системах без виртуализации идёт по физическим адресам. Очевидно, что внутри виртуальной машины необходимо транслировать такие адреса, что превращается в накладные расходы и понижение эффективности монитора. 

Решение состоит в использовании устройства IOMMU (\abbr Input output memory management unit), позволяющего контролировать обращения хозяйских устройств к физической памяти. 

\subsection{Расширение принципа}

Расширим условие виртуализуемости, заменив в нём слово <<инструкция>> на <<операция>>: \textbf{множество служебных \emph{операций} является подмножеством привилегированных}. При этом под операцией будем подразумевать любую архитектурно определённую активность по чтению или изменению состояния системы, в том числе инструкции, прерывания, доступы к устройствам, преобразования адресов и т.п.

При этом условие повышения эффективности виртуализации будет звучать следующим образом: \textbf{в архитектуре системы должно присутствовать минимальное число служебных операций}. Достигать его можно двумя способами: переводя служебные инструкции в разряд безвредных или уменьшая число привилегированных. Для этого большинство архитектур пошло по пути добавления в регистр состояния $M$ нового режима $r$ --- режима монитора ВМ (\abbr root mode). Он соотносится с режимом $s$ так, как $s$ --- с $u$; другими словами, \emph{обновлёный} класс привилегированных инструкций теперь вызывает ловушку потока управления, переводящую процессор из $s$ в $r$.

\section{Статус поддержки в современных архитектурах}

Рассмотрим основные современные архитектуры вычислительных систем, используемых на серверах, рабочих станциях, а также во встраиваемых системах, с точки зрения практической реализации описанных выше теоретических принципов. См. также серию статей~\cite{mpr-03-05-07-01,mpr-03-12-07-01,mpr-03-26-07-01}.

\subsection{IBM POWER}

Компания IBM была одной из первых, выведших архитектуру с аппаратной поддержкой виртуализации на рынок серверных микропроцессоров в серии POWER4 в 2001 году. Она предназначалась для создания изолированных логических разделов (\abbr logical partitions, LPAR), с каждым из которых ассоциированы один или несколько процессоров и ресурсы ввода-вывода. Для этого в процессор был добавлен новый режим гипервизора к уже присутсвовавшим режимам супервизора и пользователя. Для защиты памяти каждый LPAR ограничен в режиме с отключенной трансляцией адресов и имеет доступ лишь к небольшому приватному региону памяти; для использования остальной памяти гостевая ОС обязана включить трансляцию, контролируемую монитором ВМ.

В 2004 году развитие этой архитектуры, названное POWER5, принесло серьёзные усовершенствования механизмов виртуализации. Так, было добавлено новое устройство таймера, доступное только для монитора ВМ, что позволило ему контролировать гостевые системы более точно и выделять им процессорные ресурсы с точностью до сотой доли от процессора. Также монитор ВМ получил возможность контролировать адрес доставки прерываний --- в LPAR или в гипервизор. Самым важным же нововведением являлся тот факт, что присутствие гипервизора являлось обязательным --- он загружался и управлял системными ресурсами, даже если в системе присутствовал единственный LPAR-раздел. Поддерживаемые ОС (AIX, Linux, IBM~i) были модифицированы с учётом этого, чтобы поддерживать своеобразную паравиртуализационную схему. Для управления устройствами ввода-вывода один (или два, для балансировки нагрузки) из LPAR загружает специальную операционную систему --- virtual I/O server (VIOS), предоставляющую эти ресурсы для остальных разделов.

\subsection{SPARC}

Компания Sun, развивавшая системы UltraSPARC и ОС Solaris, предлагала виртуализацию уровня ОС (т.н. контейнеры или зоны) начиная с 2004~г. В 2005 году в многопоточных процессорах Niagara~1 была представлена аппаратная виртуализация. При этом гранулярность виртуализации была равна одному потоку (всего чип имел восемь ядер, четыре потока на каждом). 

Для взаимодействия ОС и гипервизора был представлен публичный и стабильный интерфейс для привилегированных приложений~\cite{sun4v-spec}, скрывающий от ОС большинство архитектурных регистров.

Для трансляции адресов используется описанная ранее двухуровневая схема с виртуальными, реальными и физическими адресами. При этом TLB не хранит промежуточный адрес трансляции. 

\subsection{Intel IA-32 и AMD AMD64}

В отличие от POWER и SPARC, архитектура IA-32 (и её расширение AMD64) никогда не была подконтрольна одной компании, которая могла бы добавлять функциональность (пара)виртуализации между аппаратурой и ОС, нарушающую обратную совместимость с существующими операционными системами. Кроме того, в ней явно нарушены условия эффективной виртуализации --- около 17 служебных инструкций не являются привилегированными, что мешало создать аппаратно поддерживаемые мониторы ВМ. Однако программные мониторы существовали и до 2006 года, когда Intel представила технологию VT-x, а AMD --- похожую, но несовместимую с ней AMD-V. 

Были представлены новые режимы процессора --- VMX root и non root, и уже существовавшие режимы привилегий 0--3 могут быть использованы в обоих из них. Переход между режимами может быть осуществлён с помощью новых инструкций \texttt{vmxon} и \texttt{vmxoff}. 

Для хранения состояния гостевых систем и монитора используется новая структура VMCS (\abbr virtual machine control structure), копии которой размещены в физической памяти и доступны для монитора ВМ.

Интересным решением является конфигурируемость того, какие события в госте будут вызывать событие ловушки и переход в гипервизор, а какие оставлены на обработку ОС. Например, для каждого гостя можно выбрать, будут ли внешние прерывания обрабатываться им или монитором; запись в какие биты контрольных регистров \texttt{CR0} и \texttt{CR4} будет перехватываться; какие исключения должны обрабатываться гостём, а какие --- монитором и т.п. Данное решение позволяет добиваться компромисса между степенью контроля над каждой ВМ и эффективностью виртуализации. Таким образом, для доверенных гостей контроль монитора может быть ослаблен, тогда как одновременно исполняющиеся с ними сторонние ОС будут всё так же под его строгим наблюдением. Для оптимизации работы TLB используется описанная выше техника тэгирования его записей с помощью ASID (\abbr address space identifier). Для ускорения процесса трансляции адресов двухуровневая схема трансляции получила имя Intel EPT (\abbr extended page walk).

\subsection{Intel IA-64 (Itanium)}

Intel добавила аппаратную виртуализацию в Itanium (технология VT-i~\cite{vtx}) одновременно с IA-32 --- в 2006 году. Специальный режим включался с помощью нового бита в статусном регистре \texttt{PRS.vm}. С включенным битом ранее служебные, но не привилегированные инструкции начинают вызывать ловушку и выход в монитор. Для возвращения в режим гостевой ОС используется инструкция \texttt{vmsw}. Часть инструкций, являющаяся служебными, при включенном режиме виртуализации генерируют новый вид синхронного исключения, для которого выделен собственный обработчик.

Поскольку операционная система обращается к аппаратуре посредством специального интерфейса PAL (\abbr processor abstraction level), последний был расширен, чтобы поддерживать такие операции, как создание и уничтожение окружений для гостевых систем, сохранение и загрузка их состояния, конфигурирование виртуальных ресурсов и т.д. Можно отметить, что добавление аппаратной виртуализации в IA-64 потребовало меньшего количества усилий по сравнению с IA-32.

\subsection{ARM}

Архитектура ARM изначально была предназначена для встраиваемых и мобильных систем, эффективная виртуализация которых, по сравнению с серверными системами, долгое время не являлась ключевым фактором коммерческого и технологического успеха. Однако в последние годы наметилась тенденция к использованию ВМ на мобильных устройствах для обеспечения защиты критически важных частей системного кода, например, криптографических ключей, используемых при обработке коммерческих транзакций. Кроме того, процессоры ARM стали продвигаться на рынок серверных систем, и это потребовало расширить архитектуру и добавить в неё такие возможности, как поддержка адресации больших объёмов памяти и виртуализация.

Оба аспекта были отражены в избранном компанией ARM подходе к развитию своей архитектуры. На рис.~\ref{fig:arm-vt-trustzone} представлена схема, подразумевающая вложенность двух уровней виртуализации, представленная в 2010 году в обновлении архитектуры Cortex A15~\cite{arm-a15}. 

\begin{figure}[htb]
    \centering
    % \includegraphics[width=\textwidth]{./arm-vt-trustzone-crop}
\begin{tikzpicture}[font=\tiny, every node/.style={draw, minimum height=0.6cm, align=center, inner sep=2pt}, node distance=0.2cm]
    \node[minimum width=1.5cm] (app11) {Приложение 1};
    \node[right =of app11, minimum width=1.5cm] (app12) {Приложение 2};
    \node[right =of app12, minimum width=1.5cm] (app21) {Приложение 1};
    \node[right =of app21, minimum width=1.5cm] (app22) {Приложение 2};
    
    \node[right =of app22, minimum width=1.5cm] (trust1) {Доверенное \\приложение 1};
    \node[right =of trust1, minimum width=1.5cm] (trust2) {Доверенное \\приложение 2};
    
    \node[below =of app11.south west, anchor=north west, minimum width=3.2cm] (os1) {Гостевая ОС 1};
    \node[below =of app21.south west, anchor=north west, minimum width=3.2cm] (os2) {Гостевая ОС 2};
    \node[below =of trust1.south west, anchor=north west, minimum width=3.2cm] (trust-os) {Доверенная ОС};
    
    \node[below =of os1.south west, anchor=north west, minimum width=6.6cm] (vmm) {Монитор виртуальных машин};
    \node[below =of vmm.south west, anchor=north west, minimum width=10.0cm] (trust-vmm) {Монитор TrustZone};
    
    \draw[dashed] ([yshift=0.1cm] trust-vmm.north west) -- ([yshift=0.1cm] trust-vmm.north east);
    \draw[dashed] ([yshift=0.1cm] vmm.north west) -- ([yshift=0.1cm] vmm.north east);
    \draw[dashed] ([xshift=0.1cm, yshift=-0.1cm] vmm.south east) -| ([xshift=0.1cm] app22.north east);
    
\end{tikzpicture}
    \caption[Виртуализация ARM]{Виртуализация ARM. Монитор TrustZone обеспечивает изоляцию и криптографическую аутентификацию доверенного <<мира>>. В обычном <<мире>> используется собственный монитор ВМ}
    \label{fig:arm-vt-trustzone}
\end{figure}

Для обеспечения изоляции критических компонент используется первый слой виртуализации, называемый TrustZone. С его помощью все запущенные программные компоненты  делятся на два <<мира>> --- доверенный и обычный. В первой среде исполняются те части системы, работа которых не должна быть подвластна внешним влияниям обычного кода. Во второй среде исполняются пользовательские приложения и операционная система, которые теоретически могут быть скомпрометированы. Однако обычный <<мир>> не имеет доступа к доверенному. Монитор TrustZone обеспечивает доступ в обратном направлении, что позволяет доверенному коду контролировать состояние аппаратуры.

Второй слой виртуализации исполняется под управлением недоверенного монитора и предоставляет возможности мультиплексирования работы нескольких пользовательских ОС. В нём добавлены новые инструкции \texttt{HVC} и \texttt{ERET} для входа и выхода в/из режим(а) гипервизора. Для событий ловушки использован ранее зарезервированный вектор прерываний 0x14, добавлены новые регистры: указатель стэка \texttt{SPSR}, состояние виртуальных ресурсов \texttt{HCR} и регистр <<синдрома>> \texttt{HSR}, в котором хранится причина выхода из гостя  в монитор, что позволяет последнему быстро проанализировать ситуацию и проэмулировать необходимую функциональность без избыточного чтения состояния гостя.

Так же, как это сделано в рассмотренных ранее архитектурах, для ускорения механизмов трансляции адресов используется двухуровневая схема, в которой физические адреса гостевых ОС являются промежуточными. Внешние прерывания могут быть настроены как на доставку монитору, который потом перенаправляет их в гость с помощью механизма виртуальных прерываний, так и на прямую отправку в гостевую систему.

\subsection{MIPS}

Процессоры MIPS развивались в направлении, обратном наблюдаемому для ARM: от высокопроизводительных систем к встраиваемым и мобильным. Тем не менее, аппаратная виртуализация для неё появилась относительно недавно, в 2012 г. Архитектура MIPS R5 принесла режим виртуализации MIPS VZ~\cite{mips-vz}. Он доступен как для 32-битного, так и для 64-битного варианта архитектуры.

Добавленное архитектурное состояние позволяет хранить контекст ВМ и монитора отдельно. Например, для нужд гипервизора введена копия системного регистра \texttt{COP0}, независимая от копии гостя. Это позволяет оптимизировать время переключения между ними, в то время как переключение между несколькими гостевыми ОС требует обновления \texttt{COP0} содержимым из памяти и является менее эффективным. Кроме того, часть бит гостевого регистра, описывающие набор возможностей текущего варианта архитектуры и потому ранее используемые только для чтения, из режима монитора доступны для записи, что позволяет ему декларировать возможности, отличные от действительно присутствующих на хозяине.

Привилегии гипервизора, операционной системы и пользователя образуют т.н. луковую (\abbr onion) модель. В ней обработка прерываний идёт снаружи внутрь, т.е. сначала каждое из них проверяется на соответствие правилам монитора, затем ОС. Синхронные исключения (ловушки), наоборот, обрабатываются сперва ОС, а затем монитором.

Так же, как это сделано в рассмотренных ранее архитектурах, для ускорения механизмов трансляции адресов используют тэги в TLB и двухуровневую трансляцию в MMU. Для поддержки разработки паравиртуализационных гостей добавлена новая инструкция \texttt{hypercall}, вызывающая ловушку и выход в режим монитора.

\section{Дополнительные темы}

В заключение данной главы рассмотрим дополнительные вопросы обеспечения эффективной виртуализации, связанные с переключением между режимами монитора и ВМ.

\subsection[Уменьшение частоты и выходов в монитор]{Уменьшение частоты и выходов в режим монитора с помощью предпросмотра инструкций}

Частые прерывания работы виртуальной машины из-за необходимости выхода в монитор негативно влияют на скорость симуляции.  Несмотря на то, что производители процессоров работают над уменьшением связанных с этими переходами задержек (для примера см. таблицу~\ref{tab:vmexit-latency}), они всё же достаточно существенны, чтобы пытаться минимизировать их частоту возникновения.

\begin{table}[htb]
\centering
\begin{tabular}{|l|l|r|}\hline
\textbf{Микроархитектура} & \textbf{Дата запуска} & \textbf{Задержка, тактов} \\\hline
Prescott     & 3 кв. 2005 & 3963 \\\hline
Merom        & 2 кв. 2006 & 1579 \\\hline
Penryn       & 1 кв. 2008 & 1266 \\\hline
Nehalem      & 3 кв. 2009 & 1009 \\\hline
Westmere     & 1 кв. 2010 & 761 \\\hline
Sandy Bridge & 1 кв. 2011 & 784 \\\hline
\end{tabular}
\caption[Длительность перехода между режимами аппаратной виртуализации]{Длительность перехода между режимами аппаратной виртуализации для различных поколений микроархитектур процессоров Intel IA-32 (данные взяты из~\cite{Agesen:2012:STA:2342821.2342856})}
\label{tab:vmexit-latency}
\end{table}

Как уже было обозначено в главе~\ref{chapter04}, если одна из техник симуляции оказывается неэффективной, имеет смысл переключиться на некоторую другую, например, на интерпретацию или двоичную трансляцию.

На практике исполнения ОС характерна ситуация, что инструкции, вызывающие ловушки потока управления, образуют \emph{кластера}, в которых две или более из них находятся недалеко друг от друга, тогда как расстояние между кластерами значительно. В следующем блоке кода для IA-32 приведён пример такого кластера. Звёздочкой обозначены все инструкции, вызывающие выход в монитор.

\begin{lstlisting}
* in %al,%dx
* out $0x80,%al
  mov %al,%cl
  mov %dl,$0xc0
* out %al,%dx
* out $0x80,%al
* out %al,%dx
* out $0x80,%al
\end{lstlisting}

Для того, чтобы избежать повторения сценария: выход из ВМ в монитор, интерпретация инструкции, обратный вход в ВМ только для того, чтобы на следующей инструкции вновь выйти в монитор, --- используется \textit{предпросмотр} инструкций~\cite{Agesen:2012:STA:2342821.2342856}. После обработки ловушки, прежде чем монитор передаст управление обратно в ВМ, поток инструкций просматривается на несколько инструкций вперёд в поисках привилегированных инструкций. Если они обнаружены, симуляция на некоторое время переключается в режим двоичной трансляции. Тем самым избегается негативное влияние эффекта кластеризации привилегированных инструкций.

\subsection{Рекурсивная виртуализация}

Ситуация, когда монитор виртуальных машин запускается под управлением другого монитора, непосредственно исполняющегося на аппаратуре, называется \textit{рекурсивной виртуализацией}. Теоретически она может быть не ограничена только двумя уровнями --- внутри каждого монитора ВМ может исполняться следующий, тем самым образуя иерархию гипервизоров.

Возможность запуска одного гипервизора под управлением монитора ВМ (или, что тоже самое, симулятора) имеет практическую ценность.  Любой монитор ВМ --- достаточно сложная программа, к которой обычные методы отладки приложений и даже ОС неприменимы, т.к. он загружается очень рано в процессе работы системы, когда отладчик подключить затруднительно. Исполнение под управлением симулятора позволяет инспектировать и контролировать его работу с самой первой инструкции.
 
Голдберг и Попек в своей упомянутой ранее работе рассмотрели вопросы эффективной поддержки в том числе и рекурсивной виртуализации. Однако их выводы, к сожалению, не учитывают многие из упомянутых выше особенностей современных систем. 

Рассмотрим одно из затруднений, связанных со спецификой вложенного запуска мониторов ВМ --- обработку ловушек и прерываний. 
В простейшем случае за обработку всех типов исключительных ситуаций всегда отвечает самый внешний монитор, задача которого --- или обработать событие самостоятельно, тем самым <<спрятав>> его от остальных уровней, или передать его следующему. 

Как для прерываний, так и для ловушек это часто оказывается неоптимальным --- событие должно пройти несколько уровней иерархии, каждый из которых внесёт задержку на его обработку. На рис.~\ref{fig:recursive-vm} показана обработка двух типов сообщений --- прерывания, возникшего во внешней аппаратуре, и ловушки потока управления, случившейся внутри приложения.

\begin{figure}[htb]
    \centering
\begin{tikzpicture}[font=\small, >=latex, inner sep=0.2cm]
    \node[draw] (app) {Приложение};
    \node[above=0.2cm of app] (vm1-n) {Монитор 1};
    \node[draw, fit = (app) (vm1-n)] (vm1) {};
    \node[above=0.2cm of vm1-n] (vm2-n) {Монитор 2};
    \node[draw, fit = (app) (vm1) (vm2-n)] (vm2) {};
    \node[above=0.2cm of vm2-n] (vm3-n) {Монитор 3};
    \node[draw, fit = (app) (vm1) (vm3-n)] (vm3) {};
    
    \node[above=0.25cm of vm3, align=center, inner sep=2pt] (int) {Событие \\ в клавиатуре};
%     \node[right=0.25cm of app, align=center] (trap) {Ловушка};
    
    \draw[->] (int.west) to[bend right=80] (vm3-n.west);
    \draw[->] (vm3-n.west) to[bend right=80] (vm2-n.west);
    \draw[->] (vm2-n.west) to[bend right=80] (vm1-n.west);
    
    \draw[->] (app.east) to[bend right=80] node[sloped, above] {Ловушка} (vm3-n.east);
    \draw[->] (vm3-n.east) to[bend left=80] (vm2-n.east);
    \draw[->] (vm2-n.east) to[bend left=80] (vm1-n.east);
    
гипер\end{tikzpicture}
    \caption[Рекурсивная виртуализация]{Рекурсивная виртуализация. Все события должны обрабатываться внешним монитором, который спускает их вниз по иерархии, при этом формируется задержка}
    \label{fig:recursive-vm}
\end{figure}

Для оптимальной обработки различных типов ловушек и прерываний для каждого из них должен быть выбран уровень иерархии мониторов ВМ, и при возникновении события управление должно передаваться напрямую этому уровню, минуя дополнительную обработку вышележащими уровнями и без связанных с этим накладных расходов.

Существуют предложения об интерфейсах между вложенными уровнями виртуализации~\cite{recursive-virt-poon}, которые позволили бы эффективно поддерживать вложенность нескольких мониторов ВМ. Однако на практике не было анонсировано реализации подобной или аналогичной технологии в продукции. Современные процессоры аппаратно поддерживают максимум один монитор ВМ.

\iftoggle{hasquiz}{
	\input{chapter14-questions}
}{}

\iftoggle{webpaper}{
    \printbibliography[title={Литература}]
}{}

