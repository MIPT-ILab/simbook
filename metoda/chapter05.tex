\chapter{Моделирование с~использованием трасс}\label{chapter05}

\dictum[А.С. Пушкин]{Там на неведомых дорожках следы невиданных зверей.}

Симуляция на основе трасс (\abbr trace driven simulation) базируется на возможности использования истории дискретных событий для нужд симуляций. Под трассами (\abbr trace --- след) понимаются истории событий, произошедших в системе за определённый период времени и сохранённые в порядке их возникновения в файл~\cite{DBLP:conf/ispass/RicoDCERV11}. В каждой записи содержится информация об изменении состояния системы из-за внешних или внутренних факторов. 

Повторная симуляция состоит в <<проигрывании>> трассы\footnote{По аналогии с магнитными лентами, когда-то использовавшимися для хранения аудиозаписей.} и соответствующем ей изменении состояния модели.

\section{История событий в~симуляции}

Рассмотренные в предыдущих главах функциональные модели позволяли наблюдать течение симулируемого времени и возникающие внутри симуляции эффекты в режиме реального хозяйского времени. В частности, это позволяло обеспечивать взаимодействие модели с внешним  пользователем, таким образом приводя систему к различным промежуточным и конечным состояниям. Однако, не всегда такая симуляция, \textit{управляемая исполнением} (\abbr execution-driven simulation), необходима или целесообразна. Она может требовать значительные вычислительные ресуры и/или быть очень медленной, и это будет ограничивать скорость исследований.

В отличие от неё, симуляция, управляемая трассами, использует эволюцию системы, произошедшую когда-то в прошлом и сохранённую в постоянном хранилище. 

Формат и содержимое трассы зависят от её назначения. В общем случае она может содержать упорядоченную запись как внешних, так и внутренних событий. Например, в случае изучения некоторого ЦПУ в трассе будут отражены доступы в память и порты ввода-вывода, приходящие прерывания и исключения. Текстовое представление трассы может иметь следующий вид:

\begin{lstlisting}
time=10 read  addr=0x45df4 result=0x0455
time=14 write addr=0x35df4 data=0xffff
time=20 interrupt 10
time=25 port write addr=0x10 data=0xabcd
\end{lstlisting}

В данном примере отражены характерные составляющие трассы такого типа:
\begin{itemize*}
    \item Моменты времени возникновения событий.
    \item Описание типа события.
    \item Параметры события.
    \item Результаты выполнения (если есть).
\end{itemize*}


\section{Применения трасс}

Каждая трасса соответствует фиксированной последовательности событий. \todo

\subsection{Детерминистичный ввод}

\todo{Написать}

Для получения трассы проводится эксперимент, в котором все события ввода данных 

Примеры использования
\begin{itemize*}
    \item Ввод пользователя с использованием клавиатуры и мыши. Во входную трассу попадают все события нажатия и отпускания клавиш и движений мыши вместе с метками времени, когда они произошли.
    \item Сетевое взаимодействие. В этом случае записываются все пакеты, пришедшие на сетевой интерфейс моделируемой или реальной системы~\cite{network-simulation}.
    \item Информация с различных физических сенсоров, таких как датчики положения, освещённости, координаты GPS/ГЛОНАСС и др.
\end{itemize*}

Для всех этих примеров характерна общая черта --- в реальности практически невозможно дважды получить идентичную (вплоть до интервалов между событиями) последовательность входных значений. 

\subsection{Валидация симулятора}
Ещё одно применение трасс состоит в валидации имитационных моделей, т.е. проверка их корректности и выявление ошибок. Для этого используется <<эталонная>> трасса, полученная с помощью некоторого доверенного источника, например, из работы референсного симулятора или даже реальной аппаратуры, исполнявшего некоторый сценарий. Затем этот же сценарий исполняется на верифицируемом симуляторе. Архитектурное состояние после каждого его шага сравнивается с соответствующей записью в трассе, и, если обнаружено расхождение, то оно сообщается, и симуляция останавливается (рис.~\ref{fig:trace-verification}).

\begin{figure}[htp]
    \centering
    \begin{tikzpicture}[font=\small, >=latex]
        \begin{scope}[start chain,node distance=5mm, every node/.style={on chain, draw},]
            \node []  (ref-start) {};
            \node []              {};
            \node []              {};
            \node []              {};
            \node []  (ref-true)  {};
            \node []              {};
            \node []              {};
            \node []  (ref-end)   {};
        \end{scope}
        
        \begin{scope}[start chain,node distance=5mm, every node/.style={on chain,join, draw}, every join/.style={->}]
            \node [below=of ref-start]  (test-start) {};
            \node []              {};
            \node []              {};
            \node []              {};
            \node [fill=black!10]  (test-end)  {};
        \end{scope}
        
        \coordinate  (pnt) at (barycentric cs:ref-start=0.5,test-start=0.5);              
        \node[thick, draw, left=0.5cm of pnt] (initial-state) {};    
        \draw[->] (initial-state) -- (ref-start);
        \draw[->] (initial-state) -- (test-start);
        
        \node[left=of ref-start] {Эталонная трасса};
        \node[left=of test-start] {Проверяемая смуляция};
        
        \node[align=center, below=1cm of initial-state, inner sep=1pt] (init-label) {Начальное состояние};
        \draw[dotted] (init-label) -- (initial-state);
        
        \node[draw, dashed, fit = (ref-true) (test-end)] (diffbox) {};
        \node[right = 0.5cm of init-label] (difflabel) {Расхождение состояний};
        \draw[dotted] (difflabel) -- (diffbox);
        
    \end{tikzpicture}
    \caption[Верификация симулятора с помощью эталонной трассы]{Верификация модели с помощью эталонной трассы на каждом шаге симуляции}
    \label{fig:trace-verification}
\end{figure}

\subsection[Изучение пространства конфигураций]{Изучение пространства конфигураций с~помощью трассировки}

Нет большой пользы в том, чтобы раз за разом моделировать одно и то же явление, всегда, в конце концов, получая один и тот же результат. Однако можно в некоторых пределах менять характеристики частей модели, при этом оставляя трассу неизменной. Ключевая идея состоит в том, что порядок и структура событий будут одинаковыми для параметризованных запусков систем, и поэтому нет необходимости многократного прогона имитационной модели, достаточно сохранить порядок событий один раз. Например, можно модифицировать модель потребления электроэнергии узлами системы. При этом история доступов в память не изменится, значит, её можно сохранить в трассу, которую затем использовать для прогона на изменённой модели для получения новых значений искомых величин.

Рассмотрим более подробно другой пример использования  симуляции с помощью трасс: изучение скорости работы некоторой программы на новой микроархитектуре; при этом производится сравнение со старой уже существующей. Обе системы совместимы на уровне макрокоманд, однако их внутреннее устройство различно. 

\begin{enumerate*}
    \item Трасса записывается на реальной (старой) аппаратуре, в неё попадают все доступы в память (с результатами отдельных чтений и записей), а также другие внешние и внутренние события (прерывания, исключения). 
    \item Сохранённые результаты подаются на модель, которая использует их как историю взаимодействия с внешним миром, при этом изменяя своё внутреннее состояние соответствующим образом и сообщая задержки, при этом возникающие. 
    \item На этапе анализа не приходится писать точную имитационную модель новой аппаратуры, достаточно иметь лишь упрощённую схему задержек (рис.~\ref{fig:tracing}).
\end{enumerate*}

\begin{figure}[htb]
    \centering
%     \includegraphics[width=0.8\textwidth]{./tracing-crop}
    \begin{tikzpicture}[node distance=0.3cm, dot/.style={fill=black,circle,inner sep=0.05cm}]
        \node[draw, rounded corners, inner ysep=0.25cm] (ev1) {};
        \node[draw, rounded corners, inner ysep=0.25cm, right of=ev1] (ev2) {};
        \node[draw, rounded corners, inner ysep=0.25cm, right of=ev2] (ev3) {};
        \node[draw, rounded corners, inner ysep=0.25cm, right of=ev3] (ev4) {};
        \node[draw, rounded corners, inner ysep=0.25cm, right of=ev4] (ev5) {};
        \node[draw, rounded corners, inner ysep=0.25cm, right of=ev5] (ev6) {};
        \node[above of=ev3, node distance = 0.5cm] (evts) {\small События};
        \node[tape, draw, fit= (ev1) (ev2) (ev3) (ev4) (ev5) (ev6) (evts)] (trace) {};
        
        \node[draw, single arrow, node distance = 1.6cm, right of = trace, inner xsep=0.35cm] (arrow1) {};
        \draw[xshift=3.5cm, scale=1.7, right of= arrow1]
        \foreach \i in {1,2,...,10} {% draw the gear
            [rotate=(\i-1)*36]  (0:0.5)  arc (0:12:0.5) -- (18:0.7)  arc (18:30:0.7) --  (36:0.5)
        };  
        \node (sim) at (4.0, 0.1) {\footnotesize Симулятор};
        \node[draw, single arrow, node distance = 3.3cm, right of = arrow1, inner xsep=0.35cm] (arrow2) {};
        
        \node[draw, yshift=-1cm, shape=semicircle, inner xsep=1.5cm, right of=arrow2, anchor=center, node distance=2.2cm] (scrc) {};
        
        \node[above of=scrc, node distance = 1.8cm] {\small Результаты};
        
         \draw[very thick, ->] (scrc.south) -- +(70:1.5cm);
        
        \foreach \a in {15, 30, 45, 60, 75, 90, 105, 120, 135, 150, 165} {
            \node[dot] at (scrc.\a) {};
        };
        \node[dot] at (scrc.south) {};
        
    \end{tikzpicture}

    \caption{Процесс использования трассы в оффлайн-симуляторе}
    \label{fig:tracing}
\end{figure}

Заметим, что начиная со второго шага нет необходимости иметь доступ к изучаемому приложению ни в виде исходного кода, ни даже в виде кода скомпилированного --- после генерации трассы они не нужны~\cite{Cain02preciseand}. Это может оказаться важным в случае, если изучаемое приложение является закрытым или каким-либо образом ограниченным в распространении ---  мы можем его исследовать и получить важные характеристики его работы по <<безликой>> трассе.

Важно понимать, что в такой трассе должны быть отражены \textit{только внешние события}: изменения во внутреннем состоянии должны отслеживаться самой моделью. В качестве примера рассмотрим задачу изучения производительности системы памяти и кэшей (о моделировании кэшей см. главу~\ref{chapter11}). Трасса содержит только информацию о помледовательности, типах и адресах доступов. Количество линий, их ёмкость, топология соединений и содержимое отдельных ячеек, а также временные характеристики кэшей определяется и отслеживаются самой моделью, которая также отвечает за полезные результаты --- вычисление среднего времени доступа в память, составление профиля времён доступов в зависимости от адресов и т.п.

%На рис.~\ref{fig:cache-study} показана схема работы оффлайн симулятора, на вход которого подаётся трасса доступов в память (в простейшем случае состоящая только из операций чтения и записи)
% \begin{figure}[htb]
    % \centering
    % \includegraphics[width=0.8\textwidth]{./cache-study-crop}
    % \caption{Пример использования трасс для изучения подсистемы кэшей}
    % \label{fig:cache-study}
% \end{figure}

\section[Ограничения трасс]{Ограничения симуляции, управляемой трассами}

Рассмотрим два \todo

\subsection{Трассы параллельных систем}

\todo{Расширить}

Очевидно, что ценность методики трассировки зависит от степени устройчивости поведения приложения при работе. Это не всегда возможно, так как поведение моделей может сильно отличаться даже на одних и тех же программах. Особенно серьёзно проблема встаёт для параллельных систем с большим числом агентов, регулярно синхронизирующих своё исполнение с помощью передачи сообщений. В этом случае затруднительно получить трассу, отражающую следующий важный аспект их работы.  Порядок событий зависит от относительных задержек между потоками, а они в свою очередь сильно зависят от параметров симуляции. Трасса одних только архитектурных событий, не учитывающая явным образом алгоритмические аспекты используемых методов синхронизации, может оказаться не отражающей  функционирование той же самой системы в немного модифицированных условиях.

рис.~\ref{fig:trace-parallel}.

\begin{figure}[htp]
    \centering
    \begin{tikzpicture}[font=\small, >=latex]
        \begin{scope}[start chain,node distance=5mm, every node/.style={on chain, draw},]
            \node []  (ref-start) {\todo};
            \node []              {};
            \node []              {};
            \node []              {};
            \node []  (ref-true)  {};
            \node []              {};
            \node []              {};
            \node []  (ref-end)   {};
        \end{scope}
                
    \end{tikzpicture}
    \caption[Предсказание переходов]{Предсказание переходов. Если в трассе будут отражены доступы в память, связанные с исполнением ветки кода, впоследствии отменённой из-за ошибки предсказания перехода, то при последующей симуляции они будут <<фантомными>>}
    \label{fig:trace-parallel}
\end{figure}

\subsection{Мисспекуляции}

\todo

Они не могут отразить многие особенности современных параллельных систем со сложными спекулятивными микроархитектурами, допускающими откат состояния, не отражаемый в архитектурной трассе.

рис.~\ref{fig:trace-misspeculation}

\begin{figure}[htp]
    \centering
    \begin{tikzpicture}[font=\small, >=latex]
        \begin{scope}[start chain,node distance=5mm, every node/.style={on chain, draw},]
            \node []  (ref-start) {\todo};
            \node []              {};
            \node []              {};
            \node []              {};
            \node []  (ref-true)  {};
            \node []              {};
            \node []              {};
            \node []  (ref-end)   {};
        \end{scope}
                
    \end{tikzpicture}
    \caption[Предсказание переходов]{Предсказание переходов. Если в трассе будут отражены доступы в память, связанные с исполнением ветки кода, впоследствии отменённой из-за ошибки предсказания перехода, то при последующей симуляции они будут <<фантомными>>}
    \label{fig:trace-misspeculation}
\end{figure}

\section{Форматы хранения трасс}

\begin{description*}
    \item[Текстовый формат] \todo
    \item[Двоичный формат] \todo
    \item[Двоичный с коррекцией симуляцией] \todo
\end{description*}

Как и к любым другим данным, опционально к трассе может быть применено сжатие алгоритмами без потерь, такими как LZW, Bzip2, LZMA и др.~\cite{sayood2002lossless}.

\section{Сэмплирование трассы}

Полная трасса некоторого, даже не самого продолжительного, процесса может содержать миллиарды событий и занимать гигабайты на устройстве хранения. Полное её проигрывание при этом отнимает много времени. Для сокращения длины эксперимента измерения проводятся только для серии коротких отрезков. Сами отрезки (\textit{сэмплы}) в исходной трассе выбираются или через регулярные интервалы, или случайным образом. Такой подход называется \textbf{сэмплированием} (\abbr sample) и позволяет получить компромисс между длительностью анализа и его точностью.

На рис.~\ref{fig:warmup} показана последовательность трёх используемых фаз при сэмплировании.
\begin{itemize*}
    \item Функциональная симуляция обладает высокой скоростью, поскольку опускает большинство внутренних деталей реализации. Она используется для быстрого \textbf{перематывания} участков между отрезками измерения. При этом потактовая модель отключена, её внутреннее состояние неопределено.
    \item \textbf{Разогрев} потактовой модели, которая получает на вход данные из трассы и симулирует изменения в состоянии модели устройства и связанные с ними задержки,  однако выдаваемые ей результаты игнорируются, так как они не соответствуют корректному исходному состоянию устройства. 
    \item \textbf{Измерение} на сэмпле производится со включенной потактовой моделью, состояние которой при достаточном разогреве соответствует реальной системе.
    \item По окончании обработки всех сэмплов полученные на них результаты суммируются и нормируются для  того, чтобы быть приведёнными к длине полной трассы.
\end{itemize*}

\begin{figure}[htp]
    \centering
    % \includegraphics[width=0.8\textwidth]{./warmup-crop}
    \begin{tikzpicture}[node distance=0cm, font=\scriptsize, text height=0.4cm, >=latex]
        \node[draw] (funcsim) {Функц. симуляция};
        \node[draw, right=of funcsim.east, anchor=west, fill=black!10] (warmup) {Разогрев};
        \node[draw, right=of warmup.east, anchor=west, fill=black!20] (measure) {Измерение};
        
        \node[draw, right=of measure.east, anchor=west] (funcsim2) {\phantom{Аууууу}};
        \node[draw, right=of funcsim2.east, anchor=west, fill=black!10] (warmup2) {\phantom{Ау}};
        \node[draw, right=of warmup2.east, anchor=west, fill=black!20] (measure2) {\phantom{Ау}};
        
        \node[draw, right=of measure2.east, anchor=west] (funcsim3) {\phantom{Аууууу}};
        \node[draw, right=of funcsim3.east, anchor=west, fill=black!10] (warmup3) {\phantom{Ау}};
        \node[draw, right=of warmup3.east, anchor=west, fill=black!20] (measure3) {\phantom{Ау}};
        
        \draw[decorate,decoration={brace, amplitude=0.15cm}] (funcsim.north west) -- (measure.north east) node[above, midway, ] {Цикл исследования};
        \draw[decorate,decoration={brace, amplitude=0.15cm}] (funcsim2.north west) -- (measure2.north east) node[above, midway, ] {Цикл исследования};
        \draw[decorate,decoration={brace, amplitude=0.15cm}] (funcsim3.north west) -- (measure3.north east) node[above, midway, ] {Цикл исследования};
        
        \node[below=of measure.east, yshift = -1cm, circle, draw] (sigma) {\large{$\Sigma$}};
        
        \draw (measure.south)  edge[->] (sigma);
        \draw (measure2.south) edge[->] (sigma);
        \draw (measure3.south) edge[->] (sigma);
        
    \end{tikzpicture}
    \caption[Сэмплирование трассы]{Сэмплирование трассы. Потактовая модель включена только на этапах разогрева и измерения, результаты собираются только при измерениях}
    \label{fig:warmup}
\end{figure}

\subsection{Частота выборки сэмплов}

Методология, использующая так называемые SimPoints~\cite{simpoint-cite, simpoint-paper}

\todo

% \section{Адаптация трассировки для изучения параллельных систем}

% Принципиальный аспект применимости трассы (т.е.) --- это сохранение порядка произошедших событий, даже если временные интервалы между ними зависят от внутреннего состояния. 

% Порядок достаточно просто определить для систем с одним потоком исполнения, например, одноядерные процессоры.

% \todo

% На рис.~\ref{fig:parallel-trace} \todo переделать картинку.

% \begin{figure}[htb]
    % \centering
    % \includegraphics[width=0.8\textwidth]{./parallel-trace-crop}
    % \caption[Трасса для параллельной системы.]{Трасса для параллельной системы. Кроме архитектурных внешних событий, в ней необходимо отмечать акты явной синихронизации независимых потоков.}
    % \label{fig:parallel-trace}
% \end{figure}

\iftoggle{hasquiz}{
    \input{chapter05-questions}
}{}

\iftoggle{webpaper}{
    \printbibliography[title={Литература}]
}{}

