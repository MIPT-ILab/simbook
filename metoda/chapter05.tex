\chapter{Моделирование с~использованием трасс}\label{chapter05}

\dictum[А.С. Пушкин]{Там на неведомых дорожках следы невиданных зверей.}

Симуляция на основе трасс (\abbr trace driven simulation) базируется на возможности использования истории дискретных событий для нужд симуляций. Под трассами (\abbr trace --- след) понимаются истории событий, произошедших в системе за определённый период времени и сохранённые в порядке их возникновения в файл. В каждой записи содержится информация об изменении состояния системы из-за внешних или внутренних факторов. 

Повторная симуляция состоит в <<проигрывании>> трассы\footnote{По аналогии с магнитными лентами, когда-то использовавшимися для хранения аудиозаписей.} и соответствующем ей изменении состояния модели.

\section{История событий в~симуляции}

Рассмотренные в предыдущих главах функциональные модели позволяли наблюдать течение симулируемого времени и возникающие внутри симуляции эффекты в режиме реального хозяйского времени. В частности, это позволяло обеспечивать взаимодействие модели с внешним  пользователем, таким образом приводя систему к различным промежуточным и конечным состояниям. Однако, не всегда такая симуляция, \textit{управляемая исполнением} (\abbr execution-driven simulation), необходима или целесообразна. Она может требовать значительные вычислительные ресуры и/или быть очень медленной, и это будет ограничивать скорость исследований.

В отличие от неё, симуляция, управляемая трассами, использует эволюцию системы, произошедшую когда-то в прошлом и сохранённую в постоянном хранилище. Это позволяет экономить вычислительные ресурсы при повторном исполнении за счёт увеличенного потребления дисковой памяти.

Формат и содержимое трассы зависят от её назначения. В общем случае она может содержать упорядоченную запись как внешних, так и внутренних событий. Например, в случае изучения некоторого ЦПУ в трассе будут отражены доступы в память и порты ввода-вывода, приходящие прерывания и исключения. Текстовое представление трассы может иметь следующий вид:

\begin{lstlisting}
time=10 read  addr=0x45df4 result=0x0455
time=14 write addr=0x35df4 data=0xffff
time=20 interrupt 10
time=25 port write addr=0x10 data=0xabcd
\end{lstlisting}

В данном примере отражены характерные составляющие трассы такого типа:
\begin{itemize*}
    \item моменты времени возникновения событий;
    \item описание типа события;
    \item параметры события;
    \item результаты выполнения (если есть).
\end{itemize*}

\section{Применения трасс}

Рассмотрим некоторые области применения симуляции, использующей трассы.

\subsection{Детерминистичный ввод}

Как было показано в предыдущих главах, сама по себе симуляция может быть сделана повторяемой. При каждом запуске с одинаковым начальным состоянием конечный результат будет идентичным. Но, если на симуляцию влияют внешние факторы, детерминистичность может нарушаться.

На этапе получения трассы проводится эксперимент, в котором все внешние события записываются в том порядке, в котором они произошли. При последующих исполнениях к симуляции подключается модель, способная воспроизводить эту запись (рис.~\ref{fig:trace-collection}).

\begin{figure}[htp]
    \centering
    \begin{tikzpicture}[font=\small, >=latex]
    \node[draw] (extern-input) {Внешний ввод};
    \node[draw, circle, right=of extern-input] (splitter) {};
    \draw     (splitter.west) -- (splitter.center);
    \draw[->] (splitter.center) -- (splitter.east);
    \draw[->] (splitter.center) -- (splitter.south);
    
    \node[draw, below=0.5cm of splitter] (recorder) {Запись};
    \node[draw, right=of splitter] (sim1) {Симулятор};
    \node[draw, tape, below=1cm of extern-input] (trace) {Трасса};
    \node[draw, below=1cm of sim1] (sim2) {Симулятор};
    
    \draw[->] (extern-input) -- (splitter);
    \draw[->] (splitter) -- (recorder);
    \draw[->] (splitter) -- (sim1);
    \draw[->] (recorder) -| (trace);
    \draw[->] (trace) -- (sim2);
        
    \end{tikzpicture}
    \caption[Этапы сбора и использования трассы]{Этапы сбора и использования трассы}
    \label{fig:trace-collection}
\end{figure}


Приведём несколько примеров сценариев использования данной техники.
\begin{itemize*}
    \item Ввод пользователя с использованием клавиатуры и мыши. Во входную трассу попадают все события нажатия и отпускания клавиш и движений мыши вместе с метками времени, когда они произошли.
    \item Сетевое взаимодействие. В этом случае записываются все пакеты, пришедшие на сетевой интерфейс моделируемой или реальной системы~\cite{network-simulation}.
    \item Информация с различных физических сенсоров, таких как датчики положения, освещённости, температуры, координаты GPS/ГЛОНАСС и др.
\end{itemize*}

Для всех этих примеров характерна общая черта --- в реальности практически невозможно дважды получить идентичную (вплоть до интервалов между событиями) последовательность входных значений. 

\subsection{Валидация симулятора}
Ещё одно применение трасс --- это валидация имитационных моделей, т.е. проверка их корректности и выявление ошибок. Для этого используется <<эталонная>> трасса, полученная с помощью некоторого доверенного источника, например, из работы референсного симулятора или реальной аппаратуры, исполнявших некоторый сценарий. Затем этот же сценарий исполняется на верифицируемом симуляторе. Архитектурное состояние после каждого его шага сравнивается с соответствующей записью в трассе, и, если обнаружено расхождение, то оно сообщается, и симуляция останавливается (рис.~\ref{fig:trace-verification}).

\begin{figure}[htp]
    \centering
    \begin{tikzpicture}[font=\small, >=latex]
        \begin{scope}[start chain,node distance=5mm, every node/.style={on chain, draw},]
            \node []  (ref-start) {};
            \node []              {};
            \node []              {};
            \node []              {};
            \node []  (ref-true)  {};
            \node []              {};
            \node []              {};
            \node []  (ref-end)   {};
        \end{scope}
        
        \begin{scope}[start chain,node distance=5mm, every node/.style={on chain,join, draw}, every join/.style={->}]
            \node [below=of ref-start]  (test-start) {};
            \node []              {};
            \node []              {};
            \node []              {};
            \node [fill=black!10]  (test-end)  {};
        \end{scope}
        
        \coordinate  (pnt) at (barycentric cs:ref-start=0.5,test-start=0.5);              
        \node[thick, draw, left=0.5cm of pnt] (initial-state) {};    
        \draw[->] (initial-state) -- (ref-start);
        \draw[->] (initial-state) -- (test-start);
        
        \node[left=of ref-start] {Эталонная трасса};
        \node[left=of test-start] {Проверяемая смуляция};
        
        \node[align=center, below=1cm of initial-state, inner sep=1pt] (init-label) {Начальное состояние};
        \draw[dotted] (init-label) -- (initial-state);
        
        \node[draw, dashed, fit = (ref-true) (test-end)] (diffbox) {};
        \node[right = 0.5cm of init-label] (difflabel) {Расхождение состояний};
        \draw[dotted] (difflabel) -- (diffbox);
        
    \end{tikzpicture}
    \caption[Верификация симулятора с помощью эталонной трассы]{Верификация модели с помощью эталонной трассы на каждом шаге симуляции}
    \label{fig:trace-verification}
\end{figure}

\subsection[Изучение пространства конфигураций]{Изучение пространства конфигураций с~помощью трассировки}

Нет большой пользы в том, чтобы раз за разом моделировать одно и то же явление, всегда, в конце концов, получая один и тот же результат. Однако можно в некоторых пределах менять характеристики частей модели, при этом оставляя трассу неизменной. Ключевая идея состоит в том, что порядок и структура событий будут одинаковыми для таких запусков систем. Поэтому нет необходимости многократного прогона имитационной модели, достаточно сохранить порядок событий один раз. Например, можно модифицировать модель потребления электроэнергии узлами системы. При этом история доступов в память не изменится, значит, её можно сохранить в трассу, которую затем использовать для прогонов на изменённой модели для получения новых значений искомых величин.

Рассмотрим более подробно другой пример использования  симуляции с помощью трасс: изучение скорости работы некоторой программы на процессоре с новой микроархитектурой. При этом трасса была собрана на предыдущем, уже существующем процессоре. Оба они совместимы на уровне машинных команд, однако их внутреннее устройство различно. 

Для этого выполняются следующие действия.

\begin{enumerate*}
    \item Трасса записывается на реальной (старой) аппаратуре, в неё попадают все доступы в память (с результатами отдельных чтений и записей), а также другие внешние и внутренние события (прерывания, исключения). 
    \item Сохранённые результаты подаются на модель, которая использует их как историю взаимодействия с внешним миром, при этом изменяя своё внутреннее состояние соответствующим образом и сообщая задержки, при этом возникающие. 
    \item На этапе анализа не приходится писать точную имитационную модель новой аппаратуры, достаточно иметь лишь упрощённую схему задержек (рис.~\ref{fig:tracing}).
\end{enumerate*}

\begin{figure}[htb]
    \centering
%     \includegraphics[width=0.8\textwidth]{./tracing-crop}
    \begin{tikzpicture}[node distance=0.3cm, dot/.style={fill=black,circle,inner sep=0.05cm}]
        \node[draw, rounded corners, inner ysep=0.25cm] (ev1) {};
        \node[draw, rounded corners, inner ysep=0.25cm, right of=ev1] (ev2) {};
        \node[draw, rounded corners, inner ysep=0.25cm, right of=ev2] (ev3) {};
        \node[draw, rounded corners, inner ysep=0.25cm, right of=ev3] (ev4) {};
        \node[draw, rounded corners, inner ysep=0.25cm, right of=ev4] (ev5) {};
        \node[draw, rounded corners, inner ysep=0.25cm, right of=ev5] (ev6) {};
        \node[above of=ev3, node distance = 0.5cm] (evts) {\small События};
        \node[tape, draw, fit= (ev1) (ev2) (ev3) (ev4) (ev5) (ev6) (evts)] (trace) {};
        
        \node[draw, single arrow, node distance = 1.6cm, right of = trace, inner xsep=0.35cm] (arrow1) {};
        \draw[xshift=3.5cm, scale=1.7, right of= arrow1]
        \foreach \i in {1,2,...,10} {% draw the gear
            [rotate=(\i-1)*36]  (0:0.5)  arc (0:12:0.5) -- (18:0.7)  arc (18:30:0.7) --  (36:0.5)
        };  
        \node (sim) at (4.0, 0.1) {\footnotesize Симулятор};
        \node[draw, single arrow, node distance = 3.3cm, right of = arrow1, inner xsep=0.35cm] (arrow2) {};
        
        \node[draw, yshift=-1cm, shape=semicircle, inner xsep=1.5cm, right of=arrow2, anchor=center, node distance=2.2cm] (scrc) {};
        
        \node[above of=scrc, node distance = 1.8cm] {\small Результаты};
        
         \draw[>=latex, very thick, ->] (scrc.south) -- +(70:1.5cm);
        
        \foreach \a in {15, 30, 45, 60, 75, 90, 105, 120, 135, 150, 165} {
            \node[dot] at (scrc.\a) {};
        };
        \node[dot] at (scrc.south) {};
        
    \end{tikzpicture}

    \caption{Процесс использования трассы в оффлайн-симуляторе}
    \label{fig:tracing}
\end{figure}

Заметим, что начиная со второго шага нет необходимости иметь доступ к изучаемому приложению ни в виде исходного кода, ни даже в виде кода скомпилированного --- после генерации трассы они не нужны~\cite{Cain02preciseand}. Это может оказаться важным в случае, если изучаемое приложение является закрытым или каким-либо образом ограниченным в распространении ---  мы можем его исследовать и получить важные характеристики его работы по <<безликой>> трассе.

Важно понимать, что в такой трассе должны быть отражены \textit{только внешние события}: изменения во внутреннем состоянии должны отслеживаться самой моделью. В качестве примера рассмотрим задачу изучения производительности системы памяти и кэшей (о моделировании кэшей см. главу~\ref{chapter11}). Трасса содержит только информацию о последовательности, типах и адресах доступов. Количество линий, их ёмкость, топология соединений и содержимое отдельных ячеек, а также временные характеристики кэшей определяется и отслеживаются самой моделью, которая также отвечает за полезные результаты --- вычисление среднего времени доступа в память, составление профиля времён доступов в зависимости от адресов и т.п.

%На рис.~\ref{fig:cache-study} показана схема работы оффлайн симулятора, на вход которого подаётся трасса доступов в память (в простейшем случае состоящая только из операций чтения и записи)
% \begin{figure}[htb]
    % \centering
    % \includegraphics[width=0.8\textwidth]{./cache-study-crop}
    % \caption{Пример использования трасс для изучения подсистемы кэшей}
    % \label{fig:cache-study}
% \end{figure}

\section[Ограничения трасс]{Ограничения симуляции, управляемой трассами}

Трасса является полезной, только если изначально записанный в ней порядок событий отражает их последовательность и для последующих запусков. Расмотрим несколько примеров, когда это не так.

\subsection{Трассы параллельных систем}

Если поток исполнения только один, и операции исполняются последовательно, то независимо от их длительности порядок будет одинаков для всех симуляций.

Проблема корректности воспроизведения событий встаёт при моделировании параллельных систем. В этом случае упорядочены только события внутри каждого потока. Их \textit{взаимный} порядок начинает зависеть от относительных задержек между потоками. Последние сильно зависят от параметров симуляции. Таким образом, трасса параллельной системы перестаёт отражать её функционирование (рис.~\ref{fig:trace-parallel}).

\begin{figure}[htp]
    \centering
    \subfigure[Сценарий 1]{
    \begin{tikzpicture}[font=\small, >=latex, scale=0.8]
        \clip (-0.1,0) rectangle (5, -6);
        \draw[->] (0,0) -- (0, -6);
        
        \draw (0.5,0) rectangle (1.5, -2);
        \draw (0.5,-2) rectangle (1.5, -3);
        \draw (0.5,-3) rectangle (1.5, -5);
        \node[align=center] at (1.0, -2.5) {A};
        
        \draw (2.5,0) rectangle (3.5, -3);
        \draw (2.5,-3) rectangle (3.5, -4);
        \draw (2.5,-4) rectangle (3.5, -5);
        \node[align=center] at (3.0, -3.5) {B};
        
    \end{tikzpicture}
    }
    \subfigure[Сценарий 2] {
    \begin{tikzpicture}[font=\small, >=latex, scale=0.8]
        \clip (-0.1,0) rectangle (5, -6);
        \draw[->] (0,0) -- (0, -6);
        
        \draw (0.5,0) rectangle (1.5, -3);
        \draw (0.5,-3) rectangle (1.5, -4);
        \draw (0.5,-4) rectangle (1.5, -5);
        \node[align=center] at (1.0, -3.5) {A};
        
        \draw (2.5,0) rectangle (3.5, -2);
        \draw (2.5,-2) rectangle (3.5, -3);
        \draw (2.5,-3) rectangle (3.5, -4);
        \node[align=center] at (3.0, -2.5) {B};
    \end{tikzpicture}        
    }
    \caption[Трассировка параллельных систем]{Трассировка параллельных систем. Порядок A и B зависит от длительности предшествующих перед ними событий. Трасса, собранная на первой симуляции, не отражает правильный порядок событий для второй}
    \label{fig:trace-parallel}
\end{figure}

Ситуация несколько упрощается, если в симулируемом процессе можно выделить события, связанные с синхронизацией отдельных потоков~\cite{DBLP:conf/ispass/RicoDCERV11}. В этом случае они должны быть помечены специальным образом в трассе, и для них должен быть задан порядок возникновения, учитываемый при проигрывании параллельной трассы. Это позволяет при использовании такой трассы проверять, что записанный в ней порядок событий совпадает с наблюдаемым. Однако для переупорядочения событий этого недостаточно.

\subsection{Предсказание переходов}

Даже если на уровне архитектуры исполнение инструкций выглядит последовательным, находящаяся ниже микроархитектура может использовать различные приёмы параллельного исполнения для уменьшения времени простоя вычислительных ресурсов. Одним из них является конвейер~\cite[глава 9]{structured-parallel}. При этом для обработки инструкций передачи управления используется техника предсказания переходов, позволяющая не дожидаться момента, когда адрес перехода будет вычислен, но продолжить исполнение инструкций по наиболее вероятному адресу. Однако, если он был предсказан неверно, то результаты вычислений, сделанных по неверному пути, должны быть отброшены. 

Если для этого исполнения была собрана трасса обращений в память, то возникает вопрос: должны ли доступы, сделанные отменёнными инструкциями, быть записаны в ней (рис.~\ref{fig:trace-misspeculation})? 
Более непонятной является ситуация, когда система, использованная для сбора трассы, и модель, проигрывающая её, реализуют разные алгоритмы предсказания переходов. В таком случае они будут делать разные предположения о наиболее вероятных ветках исполнения. Это привёдет к тому, что последовательности доступов в память после инструкций передачи управления будут различными.

\begin{figure}[htp]
    \centering
    \begin{tikzpicture}[font=\small, >=latex]
        \begin{scope}[start chain,node distance=5mm, every node/.style={on chain, draw, join}, every join/.style={->}]
            \node []              {};
            \node []              {};
            \node []              {};
            \node []    (brnch)   {};
        \end{scope}

        \begin{scope}[start chain,node distance=5mm, every node/.style={on chain, join, draw}, every join/.style={->}]
            \node [below=of brnch, xshift=7mm] (brnch-start) {};
            \node []  (brnch-middle) {};
            \node []  (brnch-end)    {};
        \end{scope}

        \begin{scope}[start chain,node distance=5mm, every node/.style={on chain, join, draw},every join/.style={->}]
            \node [above=of brnch-end, xshift=7mm] (resume) {};
            \node []              {};
            \node []              {};
            \node []    (trace-end)   {};
        \end{scope}

        \draw[->] (brnch) -- (brnch-start);
        \draw[->] (brnch-end) -- (resume);
        \node[draw, help lines, cross out, fit = (brnch-start) (brnch-end)] {};
        
        \node[above=1.3cm of brnch-middle] (arch-label)   {Архитектурно видимые доступы};
        \node[below=0.5cm of brnch-middle]    (cancel-label) {Неправильно предсказанные доступы};
        
    \end{tikzpicture}
    \caption[Предсказание переходов]{Предсказание переходов. Если в трассе будут отражены доступы в память, связанные с исполнением ветки кода, впоследствии отменённой из-за ошибки предсказания перехода, то при последующей симуляции они будут <<фантомными>>}
    \label{fig:trace-misspeculation}
\end{figure}

Таким образом, трассы не могут корректно отразить особенности современных параллельных систем и систем со спекулятивными микроархитектурами, допускающими откат состояния, не отражаемый в архитектурной трассе.

\section{Форматы хранения трасс}

Трассы обычно хранятся на диске в файле. Типы содержимого таких файлов обычно разделяют на две категории.

\begin{description*}
    \item[Текстовый формат] --- все компоненты всех записей представлены в текстовом виде. Примеры таких форматов: XML~\cite{xml-std} (\abbr eXtended Markup Language), JSON~\cite{json-std} (\abbr  JavaScript Object Notation), CSV~\cite{csv-rfc} (\abbr Comma Separated Values). Содержимое файлов в таких форматах может быть изучено человеком без каких-либо дополнительных преобразований с помощью обыкновенного текстового редактора. Общим недостатком текстовых представлений данных является их некоторая избыточность, что приводит к большому объёму файлов трасс. 
    
    \item[Двоичный формат] --- используется кодирование элементов записей трассы в битовые поля некоторой структуры. При этом достигается более компактное по сравнению с текстовым представление. Одновременно с этим обработка двоичного формата симулятором может стать более простой и быстрой. С точки зрения человека содержимое двоичных файлов может казаться <<мусором>>, и их изучение требует дополнительных инструментов, понимающих конкретный формат. В настоящее время не определено общепризнанных стандартов для двоичных данных.
%     \item[Двоичный с коррекцией симуляцией] \todo
\end{description*}

Как и к любым другим данным, опционально к трассе может быть применено сжатие алгоритмами без потерь, такими как LZW, Bzip2, LZMA и~др.~\cite{sayood2002lossless}.

\section{Сэмплирование трассы}

Полная трасса некоторого, даже не самого продолжительного в реальном времени, вычислительного процесса может содержать миллиарды событий. Возникает две трудности при работе с такой трассой. Во-первых, она занимает гигабайты на устройстве хранения. Во-вторых, полное её проигрывание при этом занимает много времени. Однако, если записанный процесс обладает некоторой регулярностью, то можно предположить, что его характеристики могут быть с достаточной точностью получены путём анализа сравнительно небольшого подмножества собранных данных с их последующей экстраполяцией на всю длительность эксперимента.

Поэтому для сокращения длительности фазы симуляции измерения проводятся только для серии коротких отрезков. Сами отрезки (\textit{сэмплы}) в исходной трассе выбираются или через регулярные интервалы, случайным образом или каким-либо другим способом. Такой подход называется \textbf{сэмплированием} (\abbr sample) и позволяет получить компромисс между длительностью анализа и его точностью.

\paragraph{Фазы сэмплирования.} На рис.~\ref{fig:warmup} показан пример последовательности трёх используемых фаз при сэмплировании для задачи анализа микроархитектурного поведения некоторой системы.

\begin{figure}[htbp]
    \centering
    % \includegraphics[width=0.8\textwidth]{./warmup-crop}
    \begin{tikzpicture}[node distance=0cm, font=\scriptsize, text height=0.4cm, >=latex]
        \node[draw] (funcsim) {Функц. симуляция};
        \node[draw, right=of funcsim.east, anchor=west, fill=black!10] (warmup) {Разогрев};
        \node[draw, right=of warmup.east, anchor=west, fill=black!20] (measure) {Измерение};
        
        \node[draw, right=of measure.east, anchor=west] (funcsim2) {\phantom{Аууууу}};
        \node[draw, right=of funcsim2.east, anchor=west, fill=black!10] (warmup2) {\phantom{Ау}};
        \node[draw, right=of warmup2.east, anchor=west, fill=black!20] (measure2) {\phantom{Ау}};
        
        \node[draw, right=of measure2.east, anchor=west] (funcsim3) {\phantom{Аууууу}};
        \node[draw, right=of funcsim3.east, anchor=west, fill=black!10] (warmup3) {\phantom{Ау}};
        \node[draw, right=of warmup3.east, anchor=west, fill=black!20] (measure3) {\phantom{Ау}};
        
        \draw[decorate,decoration={brace, amplitude=0.15cm}] (funcsim.north west) -- (measure.north east) node[align=center, above, midway] {Цикл\\исследования};
        \draw[decorate,decoration={brace, amplitude=0.15cm}] (funcsim2.north west) -- (measure2.north east) node[align=center,above, midway] {Цикл\\исследования};
        \draw[decorate,decoration={brace, amplitude=0.15cm}] (funcsim3.north west) -- (measure3.north east) node[align=center, above, midway] {Цикл\\исследования};
        
        \node[below=of measure.east, yshift = -1cm, circle, draw] (sigma) {\large{$\Sigma$}};
        
        \draw (measure.south)  edge[->] (sigma);
        \draw (measure2.south) edge[->] (sigma);
        \draw (measure3.south) edge[->] (sigma);
        
    \end{tikzpicture}
    \caption[Сэмплирование трассы]{Сэмплирование трассы. Потактовая модель включена только на этапах разогрева и измерения, результаты собираются только при измерениях}
    \label{fig:warmup}
\end{figure}


\begin{itemize*}
    \item Функциональная симуляция обладает высокой скоростью, поскольку опускает большинство внутренних деталей реализации. Она используется для быстрого прохождения (\textit{<<перематывания>>}) участков между отрезками измерения. При этом потактовая модель отключена, её внутреннее состояние неопределено.
    \item \textit{Разогрев} потактовой модели, которая получает на вход данные из трассы и симулирует изменения в состоянии модели устройства и связанные с ними задержки,  однако выдаваемые ей результаты игнорируются, так как они не соответствуют корректному исходному состоянию устройства. 
    \item \textit{Измерение} на сэмпле производится со включенной потактовой моделью, состояние которой при достаточном разогреве соответствует реальной системе.
    \item По окончании обработки всех сэмплов полученные на них результаты суммируются и нормируются для  того, чтобы быть приведёнными к длине полной трассы.
\end{itemize*}


\subsection{Частота, длина и позиции сэмплов}

Так как при сэмплировании мы явным образом отказываемся от анализа значительной части данных исходного процесса, возникает риск, что при этом теряются его важные характеристики. Чем меньше сэмплов используется и чем они короче, тем больше вносимая погрешность. Необходим предварительный анализ исследуемой задачи --- её характеризация, позволяющая оценить вносимую сэмплированием ошибку в конечный результат.

Для автоматизации принятия решения о частоте, позиции и длине сэмплов была разработана методология, использующая так называемые SimPoints~\cite{simpoint-cite, simpoint-paper}. Для этого в исследуемом приложении выделяются базовые участки, которые затем алгоритмами кластеризации объединяются в более крупные образования, показывающие сходное поведение. Затем каждому кластеру присваивается вес и внутри него находится одна точка симуляции, характеризующая его с максимальной точностью. Полный набор таких точек затем определяет число и длину сэмплов.

\iftoggle{hasquiz}{
    \input{chapter05-questions}
}{}

\iftoggle{webpaper}{
    \printbibliography[title={Литература}]
}{}

