\chapter{Моделирование с~использованием трасс}\label{chapter05}

\dictum[А.С. Пушкин]{Там на неведомых дорожках следы невиданных зверей.}

Симуляция на основе трасс (\abbr trace driven simulation) базируется на возможности переиспользования истории дискретных событий для независимых экспериментов по изучению некоторой системы. Под трассами (\abbr trace --- след) понимаются истории событий, произошедших в системе за определённый период времени, записанные в файл в порядке их возникновения~\cite{DBLP:conf/ispass/RicoDCERV11}. В отдельном событии может быть отмечена информация о том, как изменилось состояние системы из-за внешних или внутренних факторов. При этом повторная симуляция системы состоит в «проигрывании» трассы\footnote{По аналогии с магнитными лентами, когда-то использовавшимися для хранения данных.} и соответствующем ей изменении состояния модели.

Рассмотренные ранее функциональные модели были предназначены для демонстрации эффектов в изучаемых системах в режиме реального хозяйского времени, также  соответствующего (как правило, замедленному) течению симулируемого времени. В частности, это позволяло обеспечивать взаимодействие с внешним  пользователем, таким образом приводя систему к различным промежуточным и конечным состояниям. Такие модели принято характеризовывать как онлайн (\abbr online). Трассы же отображают эволюцию, произошедшую когда-то в прошлом и в общем случае не подлежащую модификации --- оффлайн (\abbr offline). 

Формат и содержимое трассы зависят от их назначения и изучаемой системы. В общем случае она должна содержать упорядоченную запись всех внешних событий. Например, в случае изучения некоторого ЦПУ для него таковыми являются доступы в память, порты ввода-вывода и прерывания, и текстовое представление трассы может иметь следующий вид:

\begin{lstlisting}
time=10 read  addr=0x45df4 result=0x0455
time=14 write addr=0x35df4 data=0xffff
time=20 interrupt 10
time=25 port write addr=0x10 data=0xabcd
\end{lstlisting}

В данном примере отражены характерные составляющие трасс:
\begin{itemize*}
    \item Моменты времени возникновения событий.
    \item Описание типа события.
    \item Параметры события.
    \item Результаты выполнения (если есть).
\end{itemize*}


\section[Изучение пространства конфигураций]{Изучение пространства конфигураций с~помощью трассировки}

Нет большой пользы в том, чтобы раз за разом моделировать одно и то же явление, всегда, в конце концов, получая один и тот же результат. Однако можно в некоторых пределах менять характеристики частей модели, при этом оставляя трассу неизменной. Ключевая идея состоит в том, что порядок и структура событий будут одинаковыми для параметризованных запусков систем, и поэтому нет необходимости многократного прогона имитационной модели, достаточно сохранить порядок событий один раз. Например, можно модифицировать модель потребления электроэнергии узлами системы. При этом история доступов в память не изменится, значит, её можно сохранить в трассу, которую затем использовать для прогона на изменённой модели для получения новых значений искомых величин.

Рассмотрим другой пример использования  симуляции с помощью трасс: изучение скорости работы некоторой программы на новой микроархитектуре; при этом производится сравнение со старой уже существующей. Обе системы совместимы на уровне макрокоманд, однако их внутреннее устройство различно. 

\begin{enumerate*}
    \item Трасса записывается на реальной (старой) аппаратуре, в неё попадают все доступы в память (с результатами отдельных чтений и записей), а также другие внешние и внутренние события (прерывания, исключения). 
    \item Сохранённые результаты подаются на модель, которая использует их как историю взаимодействия с внешним миром, при этом изменяя своё внутреннее состояние соответствующим образом и сообщая задержки, при этом возникающие. 
    \item На этапе анализа не приходится писать точную имитационную модель новой аппаратуры, достаточно иметь лишь упрощённую схему задержек (рис.~\ref{fig:tracing}).
\end{enumerate*}

\begin{figure}[htb]
    \centering
%     \includegraphics[width=0.8\textwidth]{./tracing-crop}
    \begin{tikzpicture}[node distance=0.3cm, dot/.style={fill=black,circle,inner sep=0.05cm}]
        \node[draw, rounded corners, inner ysep=0.25cm] (ev1) {};
        \node[draw, rounded corners, inner ysep=0.25cm, right of=ev1] (ev2) {};
        \node[draw, rounded corners, inner ysep=0.25cm, right of=ev2] (ev3) {};
        \node[draw, rounded corners, inner ysep=0.25cm, right of=ev3] (ev4) {};
        \node[draw, rounded corners, inner ysep=0.25cm, right of=ev4] (ev5) {};
        \node[draw, rounded corners, inner ysep=0.25cm, right of=ev5] (ev6) {};
        \node[above of=ev3, node distance = 0.5cm] (evts) {\small События};
        \node[tape, draw, fit= (ev1) (ev2) (ev3) (ev4) (ev5) (ev6) (evts)] (trace) {};
        
        \node[draw, single arrow, node distance = 1.6cm, right of = trace, inner xsep=0.35cm] (arrow1) {};
        \draw[xshift=3.5cm, scale=1.7, right of= arrow1]
        \foreach \i in {1,2,...,10} {% draw the gear
            [rotate=(\i-1)*36]  (0:0.5)  arc (0:12:0.5) -- (18:0.7)  arc (18:30:0.7) --  (36:0.5)
        };  
        \node (sim) at (4.0, 0.1) {\footnotesize Симулятор};
        \node[draw, single arrow, node distance = 3.3cm, right of = arrow1, inner xsep=0.35cm] (arrow2) {};
        
        \node[draw, yshift=-1cm, shape=semicircle, inner xsep=1.5cm, right of=arrow2, anchor=center, node distance=2.2cm] (scrc) {};
        
        \node[above of=scrc, node distance = 1.8cm] {\small Результаты};
        
         \draw[very thick, ->] (scrc.south) -- +(70:1.5cm);
        
        \foreach \a in {15, 30, 45, 60, 75, 90, 105, 120, 135, 150, 165} {
            \node[dot] at (scrc.\a) {};
        };
        \node[dot] at (scrc.south) {};
        
    \end{tikzpicture}

    \caption{Процесс использования трассы в оффлайн-симуляторе}
    \label{fig:tracing}
\end{figure}

Заметим, что начиная со второго шага нет необходимости иметь доступ к изучаемому приложению ни в виде исходного кода, ни даже в виде кода скомпилированного --- после генерации трассы они не нужны~\cite{Cain02preciseand}. Это может оказаться важным в случае, если изучаемое приложение является закрытым или каким-либо образом ограниченным в распространении ---  мы можем его исследовать и получить важные характеристики его работы по <<безликой>> трассе.

Важно понимать, что в трассе должны быть отражены только внешние события: изменения во внутреннем состоянии должны отслеживаться самой моделью. В качестве примера рассмотрим задачу изучения производительности системы памяти и кэшей (о моделировании кэшей см. главу~\ref{chapter11}). Трасса содержит только информацию о помледовательности, типах и адресах доступов. Количество линий, их ёмкость, топология соединений и содержимое отдельных ячеек, а также временные характеристики кэшей определяется и отслеживаются самой моделью, которая также отвечает за полезные результаты --- вычисление среднего времени доступа в память, составление профиля времён доступов в зависимости от адресов и т.п.

%На рис.~\ref{fig:cache-study} показана схема работы оффлайн симулятора, на вход которого подаётся трасса доступов в память (в простейшем случае состоящая только из операций чтения и записи)
% \begin{figure}[htb]
    % \centering
    % \includegraphics[width=0.8\textwidth]{./cache-study-crop}
    % \caption{Пример использования трасс для изучения подсистемы кэшей}
    % \label{fig:cache-study}
% \end{figure}

\section{Ограничения метода}

Очевидно, что ценность методики трассировки зависит от степени устройчивости поведения приложения при работе. Это не всегда возможно, так как поведение моделей может сильно отличаться даже на одних и тех же программах. Особенно серьёзно проблема встаёт для параллельных систем с большим числом агентов, регулярно синхронизирующих своё исполнение с помощью передачи сообщений. В этом случае затруднительно получить трассу, отражающую следующий важный аспект их работы.  Порядок событий зависит от относительных задержек между потоками, а они в свою очередь сильно зависят от параметров симуляции. Трасса одних только архитектурных событий, не учитывающая явным образом алгоритмические аспекты используемых методов синхронизации, может оказаться не отражающей  функционирование той же самой системы в немного модифицированных условиях.

\section{Области применения}

Кроме рассмотренного ранее в этой главе сценария изучения производительности новых систем, трассы могут использоваться для проверки корректности модели путём сравнения трассы, полученной на ней, с эталонной, взятой или с реальной аппаратуры, или с точного (но медленного) потактового симулятора.

Другая важная область использования трасс --- валидация имитационных моделей, т.е. доказательство их корректности. При этом на каждом шаге сравнивается состояние модели и состояние, записанное в «эталонной» трассе, полученной с помощью некоторого доверенного источника. При их расхождении мы можем точно сказать, какая операция привела к ошибке, что сокращает время её исправления.

Тем не менее в ряде работ озвучивается мнение, что время использования трасс для непосредственного изучения архитектур ушло, поскольку они не могут отразить многие особенности современных параллельных систем со сложными спекулятивными микроархитектурами, допускающими откат состояния, не отражаемый в архитектурной трассе.

\section{Сэмплирование трассы}

Полная трасса некоторого процесса может содержать миллиарды событий и занимать гигабайты на устройстве хранения. Полное её проигрывание при этом отнимает много времени. Для сокращения длины эксперимента измерения проводятся только для серии коротких отрезков. Сами отрезки (\textit{сэмплы}) в исходной трассе выбираются или через регулярные интервалы, или случайным образом. Такой подход называется \textbf{сэмплированием} (\abbr sample) и позволяет получить компромисс между длительностью анализа и его точностью.

На рис.~\ref{fig:warmup} показана последовательность трёх используемых фаз при сэмплировании.
\begin{itemize*}
    \item Функциональная симуляция обладает высокой скоростью, поскольку опускает большинство внутренних деталей реализации. Она используется для быстрого \textbf{перематывания} участков между отрезками измерения. При этом потактовая модель отключена, её внутреннее состояние неопределено.
    \item \textbf{Разогрев} потактовой модели, которая получает на вход данные из трассы и симулирует изменения в состоянии модели устройства и связанные с ними задержки,  однако выдаваемые ей результаты игнорируются, так как они не соответствуют корректному исходному состоянию устройства. 
    \item \textbf{Измерение} на сэмпле производится со включенной потактовой моделью, состояние которой при достаточном разогреве соответствует реальной системе.
    \item По окончании обработки всех сэмплов полученные на них результаты суммируются и нормируются для  того, чтобы быть приведёнными к длине полной трассы.
\end{itemize*}

\begin{figure}[htp]
    \centering
    % \includegraphics[width=0.8\textwidth]{./warmup-crop}
    \begin{tikzpicture}[node distance=0cm, font=\scriptsize, text height=0.4cm, >=latex]
        \node[draw] (funcsim) {Функц. симуляция};
        \node[draw, right=of funcsim.east, anchor=west, fill=black!10] (warmup) {Разогрев};
        \node[draw, right=of warmup.east, anchor=west, fill=black!20] (measure) {Измерение};
        
        \node[draw, right=of measure.east, anchor=west] (funcsim2) {\phantom{Аууууу}};
        \node[draw, right=of funcsim2.east, anchor=west, fill=black!10] (warmup2) {\phantom{Ау}};
        \node[draw, right=of warmup2.east, anchor=west, fill=black!20] (measure2) {\phantom{Ау}};
        
        \node[draw, right=of measure2.east, anchor=west] (funcsim3) {\phantom{Аууууу}};
        \node[draw, right=of funcsim3.east, anchor=west, fill=black!10] (warmup3) {\phantom{Ау}};
        \node[draw, right=of warmup3.east, anchor=west, fill=black!20] (measure3) {\phantom{Ау}};
        
        \draw[decorate,decoration={brace, amplitude=0.15cm}] (funcsim.north west) -- (measure.north east) node[above, midway, ] {Цикл исследования};
        \draw[decorate,decoration={brace, amplitude=0.15cm}] (funcsim2.north west) -- (measure2.north east) node[above, midway, ] {Цикл исследования};
        \draw[decorate,decoration={brace, amplitude=0.15cm}] (funcsim3.north west) -- (measure3.north east) node[above, midway, ] {Цикл исследования};
        
        \node[below=of measure.east, yshift = -1cm, circle, draw] (sigma) {\large{$\Sigma$}};
        
        \draw (measure.south)  edge[->] (sigma);
        \draw (measure2.south) edge[->] (sigma);
        \draw (measure3.south) edge[->] (sigma);
        
    \end{tikzpicture}
    \caption[Сэмплирование трассы]{Сэмплирование трассы. Потактовая модель включена только на этапах разогрева и измерения, результаты собираются только при измерениях}
    \label{fig:warmup}
\end{figure}


% \section{Адаптация трассировки для изучения параллельных систем}

% Принципиальный аспект применимости трассы (т.е.) --- это сохранение порядка произошедших событий, даже если временные интервалы между ними зависят от внутреннего состояния. 

% Порядок достаточно просто определить для систем с одним потоком исполнения, например, одноядерные процессоры.

% \todo

% На рис.~\ref{fig:parallel-trace} \todo переделать картинку.

% \begin{figure}[htb]
    % \centering
    % \includegraphics[width=0.8\textwidth]{./parallel-trace-crop}
    % \caption[Трасса для параллельной системы.]{Трасса для параллельной системы. Кроме архитектурных внешних событий, в ней необходимо отмечать акты явной синихронизации независимых потоков.}
    % \label{fig:parallel-trace}
% \end{figure}

\iftoggle{hasquiz}{
    \input{chapter05-questions}
}{}

\iftoggle{webpaper}{
    \printbibliography[title={Литература}]
}{}

