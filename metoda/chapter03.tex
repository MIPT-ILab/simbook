\chapter{Модели процессора на основе интерпретации}\label{chapter03}

\dictum[Уильям Томсон (лорд Кельвин)]{Понять --- значит построить модель.}

<<Интерпретатор>> в общем значении слова --- тот, кто занимается переводом текста с одного языка на другой. В контексте вычислительной техники этот термин противопоставляется трансляторам и компиляторам; последние два понятия описывают программы, преобразующие тексты на входном языке (машинном или высокого уровня) в новое представление, оперируя при этом достаточно большими его блоками --- файлами, модулями, функциями и т.п. Интерпретатор же ограничивается работой над одной <<строкой>> (например, машинной инструкцией) входного языка. Следующая строка будет преобразована (\emph{проинтерпретирована}) тогда, когда в этом возникнет необходимость.

\section{Архитектурное состояние}

Прежде чем перейти к описанию общей картины алгоритма, рассмотрим, какие структуры данных используются для представления состояния процессора в функциональной модели\footnote{Более детально об архитектурном состоянии рассказывается в главе~\ref{chapter10}; о создании потактовых моделей --- в главе~\ref{chapter09}.}.

В любом классическом процессорном устройстве всегда присутствует регистр, хранящий адрес текущей исполняемой инструкции. Например, в архитектуре IA-32~\cite{intelmanual2a} для этого используется семейство xIP: \texttt{IP}, \texttt{EIP}, \texttt{RIP}, в архитектуре ARM~\cite{arm-sdg} он имеет название \texttt{pc}, в других системах он может называться по-другому, например, \texttt{IC} (\abbr instruction counter). В дальнейшем для единообразия мы будем использовать обозначение \texttt{PC} (\abbr program counter).
%\footnote{На самом деле адрес очередной инструкции в архитектуре x86 определяется парой регистров: CS (Code Segment) и RIP (в 64 битном режиме работы) или EIP (в 32 битном) или IP (в 16 битном).}  (instruction pointer)

Кроме указателя инструкций, процессоры содержат множество других регистров, типы, назначение и параметры которых зависят от модели. В большинстве случаев присутствуют регистры общего назначения (\abbr general purpose registers, GPR), используемые в арифметических операциях и при адресации памяти.

В языке Си (и С++) описание состояния может быть представлено структурой \texttt{state_t}, содержащей поля для всех регистров, а также ссылки на внешние устройства:

\begin{lstlisting}
typedef uint32_t register_t; // ширина гостевых регистров
const int n_regs = 16; // число регистров
typedef struct {
    register_t pc; // счётчик инструкций
    register_t gpr[n_regs]; // регистры общего назначения
    uint8_t *memory; // указатель на ОЗУ
} state_t;
\end{lstlisting}

Заметим, что данное описание очень далеко от того, чтобы быть полным, однако оно даёт базовое представление того, с чем приходится иметь дело в начале разработки новой модели.

\section{Стадии работы}
Алгоритм работы в общих чертах напоминает стадии конвейера исполнения команд в настоящем процессоре\footnote{Отметим, что число  стадий может быть различно у разных моделей и варьируется от трёх до двадцати.} (рис.~\ref{fig:interp-cycle-expanded}). 

\begin{figure}[htb]
    \centering
    %\includegraphics[width=0.7\textwidth]{./interp-cycle-expanded-crop}
    \begin{tikzpicture}
		% five circles
        \foreach \A/\T in    { 90/{Извлечь инструкцию},
							   18/{Декодировать},
							  306/{Исполнить},
							  234/{Запись в память},
							  162/{Продвинуть \texttt{PC}}
			} {	
			\node[draw, circle, text width = 2.5cm, text badly centered](stage\A) at (\A:3.0cm) {\small\T};
			}
			% arrows, dumb way
			\draw[-open triangle 45, thick] (stage90) -- (stage18);
			\draw[-open triangle 45, thick] (stage18) -- (stage306);
			\draw[-open triangle 45, thick] (stage306) -- (stage234);
			\draw[-open triangle 45, thick] (stage234) -- (stage162);
			\draw[-open triangle 45, thick] (stage162) -- (stage90);
    \end{tikzpicture}
    \caption{Рабочий цикл интерпретатора}
    \label{fig:interp-cycle-expanded}
\end{figure}

\begin{enumerate*}

\item Извлечение (\abbr fetch) кода инструкции из памяти\footnote{В зависимости от того, используется ли гарвардская архитектура процессора или же архитектура фон Неймана, задействована или отдельная память инструкций, или общая память данных.} по адресу, вычисляемому из значения \texttt{PC}\footnote{Конкретная формула зависит от деталей архитектуры и текущего режима устройства.}. 

В модели это действие идентично операции чтения из памяти и может вызывать соответствующие побочные эффекты.

\item Задача декодирования (\abbr decode) состоит в том, чтобы по числу, полученному в предыдущей фазе, определить, какую операцию следует выполнить и какие аргументы в ней будут участвовать. Например, число \texttt{0x706a} в архитектуре IA-32 обозначает команду \texttt{PUSH 0x70} --- поместить в стек число 0x70. 

Алгоритм и сложность декодирования сильно зависят от сложности самого языка инструкций целевой машины. Как правило, процесс состоит из поиска и сопоставления битовых полей считанного машинного слова  со значениями из заранее созданных таблиц. В силу многих факторов (например, переменной длины инструкций, различного смысла значений в различных режимах процессора, использования префиксов и т.п.) декодирование может занимать существенную часть времени работы интерпретатора.

Теория вопроса разбора выражений (\abbr parsing) довольно детально разработана для языков высокого уровня и является <<классикой>> computer science. Cм. также <<Книгу дракона>>~\cite{dragonbook}.

\item Исполнение (\abbr execute) состоит из непосредственной симуляции функции только что декодированной инструкции. Как правило, это вычисление результата арифметической или логической операции, изменение режима модели процессора или передача контроля управления в другую секцию алгоритма.

В модели каждому коду машинной операции (\textit{опкоду}) должна соответствовать моделирующая процедура. Выбор нужной процедуры производится по опкоду:

\begin{lstlisting}
switch (opcode) {
    case OPERATION1: ...
    case OPERATION2: ...
    ...
    default: ... // unknown command
}
\end{lstlisting}


\item Запись результата (\abbr write back) операции в архитектурные регистры. Часть результатов также может быть расположена в оперативной памяти. Как и при её чтении (на этапе извлечения кода инструкции или получения входных операндов), при записи модель должна симулировать все побочные эффекты.

\item Продвижение указателя команд (\abbr advance PC) на значение, соответствующее следующей инструкции. Т.к. большая часть существующих алгоритмов состоит из линейных участков, изредка прерываемых операциями ветвления, к нему прибавляется длина только что завершённой машинной команды.

При моделировании необходимо учитывать ограниченность ширины регистра \texttt{PC} и возможность его переполнения.

\begin{lstlisting}
const int instr_size = 2; // 16 bit CPU
const int addr_mask = 0xffff; // mask overflowed bits
state_t processor; // our CPU
...
processor.pc = (processor.pc + instr_size) & addr_mask;
\end{lstlisting}

\end{enumerate*}

\section{Простой пример}

Приведем пример интерпретационной модели простого процессора со следующей архитектурой.

\paragraph{Регистры}
\begin{itemize*}
\item    \texttt{R0} --- регистр общего назначения
\item    \texttt{R1} --- регистр общего назначения
\item    \texttt{R2} --- регистр общего назначения
\item    \texttt{IP} --- указатель команд
\end{itemize*}

\paragraph{Команды}
\begin{itemize*}
    \item \texttt{ADD} --- сложение, можно прибавлять к регистру регистр или число
    \item \texttt{SUB} --- вычитание, можно вычитать из регистра число
    \item \texttt{LOAD} --- загрузка ячейки памяти в регистр
    \item \texttt{STORE} --- сохранение регистра в памяти
\end{itemize*}

\subsubsection{Описание модели в псевдокоде}

\paragraph{Структура данных для хранения результата декодирования} 
\begin{lstlisting}
struct DecodedInstr {
    enum Operation Op;
    enum Argument Arg1;
    enum Argument Arg2;
};
\end{lstlisting}

\paragraph{Архитектурное состояние модели}
\begin{lstlisting}
int R0, R1, R2, IP;  // Модель регистров
class Memory Mem;    // Модель внешней памяти
\end{lstlisting}

\paragraph{Алгоритм симуляции}
\begin{lstlisting}
for (;;) { // бесконечный цикл
    int Instr = FetchInstr();
    struct DecodedInstr DecInstr = Decode(Instr);
    Execute(DecInstr);
}

int FetchInstr() {
    return Mem.Load32Bits(IP); // Загружаем 4 байта из памяти по адресу PC
}

struct DecodedInstr Decode(int Instr) {
    switch (Instr) { // Перебираем все реализованные инструкции
    case 0: // ADD R0, R0
        return {.Op = OP_ADD, .Arg1 = ARG_R0, .Arg2 = ARG_R0};
    case 1: // ADD R0,R1
        return {.Op = OP_ADD, .Arg1 = ARG_R0, .Arg2 = ARG_R1};
    // ...
    }
}

void Execute(struct DecodedInstr DecInstr) {
    int *Arg1, *Arg2;  // Указатели на аргументы операции
    // Какой первый аргумент операции?
    switch (DecInstr.Arg1) {
        case ARG_R0: Arg1 = &R0; break;
        case ARG_R1: Arg1 = &R1; break;
        case ARG_R2: Arg1 = &R2; break;
    }
    // Какой второй аргумент операции?
    switch (DecInstr.Arg2) {
        case ARG_R0: Arg2 = &R0; break;
        case ARG_R1: Arg2 = &R1; break;
        case ARG_R2: Arg2 = &R2; break;
    }
    // Выполнить операцию
    switch (DecInstr.Op) {
    case OP_ADD:
        *Arg1 += *Arg2;
        IP += 4; // Продвинуть указатель команд на следующую инструкцию
        break;
    case OP_SUB:
        *Arg1 -= *Arg2;
        IP += 4; 
        break;
    case OP_LOAD:
        *Arg1= Mem.Load32Bits(*Arg2);
        IP += 4; 
        break;
    // ...
    }
}
\end{lstlisting}

\section{Исключения и прерывания}

Часто при обработке текущей инструкции возникает ситуация, когда нормальное её выполнение не может быть завершено, потому что  были обнаружены недопустимые условия на входные операнды (например, целочисленное деление на ноль или недоступность памяти), или возникло какое-то внешнее условие, требующее немедленной обработки. При этом архитектурное состояние процессора изменяется определённым способом (как правило, управление передаётся на обработчик возникшей ситуации), в том числе регистр \texttt{PC} начинает указывать на новый участок кода. Необходимость учитывать это оказывает соответствующее влияние на дизайн и реализацию модели.

На рис.~\ref{fig:interp-cycle-expanded-exception} изображён цикл интерпретации, учитывающий тот факт, что практически в любой момент может произойти переход в состояние обработки исключительной ситуации, вносящее изменения в архитектурное состояние, после чего цикл интерпретации начинается заново уже с новым \texttt{PC}.

\subsection{Классификация}

В документациях к различным процессорам~\cite{intelmanual-7vols, arm-sdg, weaver1994sparc} даны различные, зачастую внутренне противоречивые определения терминов, связанных с исключительными ситуациями. Тем не менее важно различать природу событий, их связь с текущим контекстом выполнения для того, чтобы корректно симулировать их эффекты. \\

\begin{figure}[htp]
    \centering
    %\includegraphics[width=0.7\textwidth]{./interp-cycle-expanded-exception-crop}
        \begin{tikzpicture}
		% five circles
        \foreach \A/\T in    { 90/{Извлечь инструкцию},
							   18/{Декодировать},
							  306/{Исполнить},
							  234/{Запись в память},
							  162/{Продвинуть \texttt{PC}}
			} {	
			\node[draw, circle, text width = 2.5cm, text badly centered](stage\A) at (\A:3.0cm) {\small\T};
			}
			
			% The exception circle
			\node[draw, circle, text width = 2.5cm, text badly centered](stageE) at (0,-6.0cm){\small Исключение};
			
			% arrows, dumb way
			\draw[-open triangle 45, thick] (stage90) -- (stage18);
			\draw[-open triangle 45, thick] (stage18) -- (stage306);
			\draw[-open triangle 45, thick] (stage306) -- (stage234);
			\draw[-open triangle 45, thick] (stage234) -- (stage162);
			\draw[-open triangle 45, thick] (stage162) -- (stage90);
			
			% arrows to exception
			\draw[dashed, thick, -latex] (stage90) .. controls (6,3) and (6,-3) .. (stageE);
			\draw[dashed, thick, -latex] (stage18) .. controls (4,-3) .. (stageE);
			\draw[dashed, thick, -latex] (stage306) .. controls (1,-4) .. (stageE.north east);
			\draw[dashed, thick, -latex] (stage234) .. controls (-2,-4) .. (stageE);
			% an edge from exception
			\draw[-open triangle 45, thick] (stageE) .. controls (-6, -3) and (-6, 3).. (stage90);
			
    \end{tikzpicture}
    \caption[Цикл интерпретатора с фазой обработки исключения]{Рабочий цикл интерпретатора. Показана возможность возникновения исключительной ситуации на любой стадии симуляции}
    \label{fig:interp-cycle-expanded-exception}
\end{figure}

Выделим основные группы исключительных событий по признакам наличия причинной связи между событиями, влиянием среды исполнения на возможность их возникновения, а также адресом возврата после их обработки. В скобках к терминам будут даны те имена, под какими они чаще всего встречаются в литературе; однако не следует полагаться на строгость данных соответствий. См. также замечания ниже.

\begin{itemize*}
    \item \textit{Синхронные с повторением текущей инструкции} (промах, \abbr fault) --- событие, связанное причинно-следственно с выполнением текущей инструкции и обусловленное <<неготовностью>> среды исполнения к её успешному завершению. Примеры таких ситуаций: отсутствие физической страницы памяти с необходимыми данными; неготовность сопроцессора выполнять работу, т.к. он требует дополнительной инициализации. В этих случаях обработчик ситуации, находящийся в операционной системе, может модифицировать среду исполнения так, что завершение инструкции станет возможным, например, загрузить нужную страницу или включить сопроцессор. Дальнейшее возвращение на \emph{тот же} \texttt{PC} с перезапуском инструкции позволит устранить проблему прозрачно для пользовательского приложения. 

    \item \textit{Синхронные без повторения текущей инструкции} (исключения, \abbr ex\-cep\-tion).  Как и в предыдущем случае, событие порождено текущей инструкцией. Однако его обработка не подразумевает её повтора, так как причина события неустранима и не связана со средой исполнения, но связана только с самой операцией и операндами. Примеры: инструкция целочисленного деления на регистр, содержащий ноль, всегда будет давать ошибку; инструкция, запрещённая к выполнению в текущем уровне привилегий, не может быть на нём исполнена никогда. Чаще всего (но не всегда!) исключения обозначают ошибку в программе. Управление после возврата из обработчика будет передано в место, не связанное с \texttt{PC} того кода, где произошло событие.

    \item \textit{Ловушки} (\abbr trap) также синхронны. При этом они обозначают явное <<желание>> программы быть прерванной и передать управление в определённую область кода --- обработчик вызова. Примером является инструкция \texttt{SYSCALL}, вызывающая системные функции операционной системы, такие как работа с файлами, создание новых процессов и т.п. Другой пример --- команда, предназначенная устройству-сопроцессору, физически отсутствующему в системе, однако ОС умеет её эмулировать и таким образом способна вернуть правильный результат прозрачно для пользовательской задачи. С точки зрения прикладного ПО ловушка --- это инструкция, семантика которой определяется не спецификацией ЦПУ, а используемой операционной системой и средой исполнения.

    После обработки ловушки и возврата счётчик инструкций будет указывать на следующую команду в потоке исполнения, т.е. будет соответствовать нормальному потоку. Отметим, что разница между ловушками и исключениями минимальна и их классификация зависит от верхнеуровневого смысла, который вкладывают в соответствующую подпрограмму-обработчик.

    \item \textit{Асинхронные прерывания} (\abbr interrupt). В отличие от всех ранее рассмотренных событий, они вызваны причинами, внешними по отношению к текущему контексту исполнения, и означают некоторое состояние внешней среды, требующее внеочередной обработки. Примеры: жёсткий диск готов передать новую порцию данных, ранее запрошенную независимым процессом; температурный датчик сигнализирует о превышении измеряемой температуры порогового значения; таймер сообщил о прошествии запрограммированного в него интервала. Прерывание никак не связано с опкодом, адресом или аргументами инструкций --- оно могло произойти чуть раньше или позже, а могло и вовсе не произойти. Однако игнорировать его в общем случае нельзя. Часто недопустимо откладывать вызов обработчика во времени дольше, чем на некоторый краткий период времени.

    Будет ли после возвращения из обработчика перезапущена инструкция, на которой возникло прерывание, зависит от конкретной архитектуры процессора, однако в любом случае её исполнение должно пройти таким образом, чтобы сам факт обработки был скрыт от прерванного приложения.
\end{itemize*}

Следует также отметить следующие особенности существующих систем.
\begin{enumerate*}
    \item Программное прерывание (\abbr software interrupt) --- событие, вызываемое специальной инструкцией (например, в IA-32 это \texttt{INT}), обработка которого напоминает вызов процедуры. Т.е., несмотря на название, оно соответствует ловушке, а не прерыванию.
    \item В некоторых архитектурах, например SPARC~\cite{weaver1994sparc}, подпрограмма-обработчик синхронного события может сама выбрать, следует ли перезапускать текущую инструкцию. Для возвращения из подпрограммы-обработчика могут использоваться две различные инструкции --- \texttt{RETRY} для перезапуска (в случае обработки промаха) и \texttt{DONE} для исполнения следующей команды за текущей (для выхода из обработки ловушек). Для поддержки такой возможности в архитектуру введён регистр \texttt{nPC}, в любой момент указывающий на следующую за текущей инструкцию. 
\end{enumerate*}

\subsection{Обработка исключительных ситуаций}

Существование исключений и прерываний (а они не используются, разве что только в узкоспециализированных микроконтроллерах) существенно усложняет логику как аппаратной системы, так и моделирующей среды. Непредсказуемость их возникновения создаёт множество веток исполнения в структурированном коде, усложняя его структуру, а также негативно влияя на скорость исполнения.

Обычный структурированный код про\-це\-дур\-ных и объек\-тно-ори\-ен\-ти\-ро\-ван\-ных языков высокого уровня состоит из вложенных вызовов процедур (методов), каждая из которых по окончании работы возвращает управление в вызвавшую процедуру по адресу, сохранённому на стеке. Однако  моделирование исключительных ситуаций подразумевает возможность их возникновения в множестве мест --- индивидуальных блоках эмуляции инструкций. При этом после изменения архитектурного состояния управление должно быть передано на начало следующего цикла интерпретации.

Забегая вперёд, заметим, что особенно остро эта проблема передачи управления встаёт не в интерпретаторах, а в двоичных трансляторах, часть кода которых создаётся динамически. При этом часто при исполнении этого кода заранее нельзя сказать, какова будет структура стека в момент обнаружения исключительной ситуации, и его развёртывание до необходимого уровня вложенности с помощью серии обычных возвратов из процедур будет достаточно дорогостоящей операцией, нивелирующей преимущества быстрого исполнения.

Естественным способом передачи управления в такой ситуации является нелокальный <<прыжок>> --- переход, использующий пару функций \texttt{setjmp()} и \texttt{longjump()}, описанных в стандарте библиотеки Си. 

Функция \texttt{setjmp} сохраняет контекст в переменной \texttt{env} и возвращает 0, если выход из неё был после её прямого вызова. Если произошёл возврат из \texttt{longjmp}, то функция возвращает ненулевое значение.

Функция \texttt{longjmp} возвращает выполнение в точку вызова \texttt{setjmp} со значением \texttt{val}. При этом все объекты с неавтоматическим выделением памяти сохраняют своё значение.

Пример использования \texttt{setjmp()} и \texttt{longjmp()}\footnote{Пример взят из Википедии: \url{http://en.wikipedia.org/wiki/Setjmp.h}.}:

\begin{lstlisting}
#include <stdio.h>
#include <setjmp.h>
 
static jmp_buf buf;
void second(void) {
  printf("second\n");/* печать на экран */
  longjmp(buf,1); /* переходит по метке setjmp и возвращает код 1*/
}
 
void first(void) {
  second();
  printf("first\n");/* этой печати не произойдёт*/
}
 
int main() {   
  if ( ! setjmp(buf) ) {
    first(); /* при исполнении вернёт код 0*/
  } else { /* по возвращении из longjmp вернёт 1*/
    printf("main\n");/* печать на экран*/
  }
  return 0;
}
\end{lstlisting}

Нельзя отрицать, что использование как нелокальных\footnote{Т.е. пересекающих границу отдельной процедуры.} переходов с помощью \texttt{longjump}, так и локальных\footnote{Внутри одной процедуры.} переходов по метке с помощью оператора \texttt{goto} языка Си нарушает модульность кода и лёгкость его чтения, а также может быть источником алгоритмических ошибок. Однако на это приходится идти ради увеличения скорости работы приложения.

\section[Преимущества и недостатки интерпретатора]{Преимущества и недостатки интерпретатора}

Главным преимуществом рассмотренной схемы является её простота в реализации, модификации и отладке. Практически всегда в проектах по созданию программной модели нового процессора первым этапом является разработка интерпретационной модели, которая затем используется как эталон для тестирования последующих улучшений модели, оптимизирующих эффективность исполнения.

Основным недостатком интерпретатора является низкая скорость. Дело в том, что если на модели ЦПУ исполняется какой-нибудь цикл (например, копирование памяти из одного места в другое), то одни и те же команды декодируются множество раз. Если данный цикл был декодирован один раз и для него был сгенерирован код, который моделирует его работу, то в дальнейшем стадию декодирования при входе в этот блок можно было бы опустить. Модели, работающие по такой схеме, принадлежат к классу трансляторов.

Однако не всегда транслятор быстрее интерпретатора. Как можно видеть из общего алгоритма работы (рис.~\ref{fig:translator}), если приложение, которое исполняется на моделируемом ЦПУ, не содержит (или содержит мало) постоянных циклов, то транслятор будет все время обнаруживать «новый» код, что приведет к постоянным тратам времени на кодогенерацию\footnote{Кроме того, в трансляторе есть дополнительные накладные расходы на  контролирование возможности использования самомодифицирующегося кода; описание механизмов выходит за рамки данной главы и описано в главе~\ref{chapter04}.}. 

\begin{figure}[htb]
    \centering
    % \includegraphics[width=0.6\textwidth]{./translator-crop}
    \begin{tikzpicture}[>=latex,
    action/.style={ rectangle, draw, node distance=2cm, text badly centered, text width=2.5cm},
    complexaction/.style={rectangle, draw, rounded corners, node distance=2cm, text badly centered},
    choice/.style={diamond, draw, aspect=2, node distance=2cm, text badly centered, text width=2.5cm, inner sep=0cm}
    ]
    \node[choice]                           (is-translated) {\scriptsize Инструкция транслирована?};
    \node[action, below of=is-translated, yshift=-1cm]   (fetch-instr)   {Извлечь инструкцию};
    \node[action, below of=fetch-instr]     (decode)        {Декодировать};
    \node[complexaction, matrix, below of=decode, yshift=-1cm, row sep=0.1cm]   (generate-code) {
        \node{Сгенерировать управляющий код}; \\
        \node[complexaction] {Управление хранилищем кода}; \\
        \node[complexaction] {Генерация кода}; \\
        \node[complexaction] {Оптимизация}; \\
        };
    \node[choice, below of= generate-code, yshift=-1cm]  (end-block)     {Конец блока?};
    \node[action, below of= end-block]      (execute)       {Исполнять};
    
    \path[->, draw] (execute.south) |- ([xshift=-3cm, yshift=-1cm] execute.west) |- ([yshift=0.6cm] is-translated.north) -- (is-translated.north);
    \path[->, draw] (is-translated.east) -|  ([xshift=2.5cm] execute.east) node[near start, above] {Да} -- (execute.east);
    \path[->, draw] (is-translated.south) --  (fetch-instr.north) node[midway, right] {Нет};
    \path[->, draw] (end-block.west) -| ([xshift=-2.5cm] end-block.west)  node[very near start, above] {Нет} |- (fetch-instr.west);
    \path[->, draw] (end-block.south) -- (execute.north) node[midway, right] {Да};
    \path[->, draw] (fetch-instr.south) -- (decode.north);
    \path[->, draw] (decode.south) -- (generate-code.north);
    \path[->, draw] (generate-code.south) -- (end-block.north);
    
    \end{tikzpicture}
    \caption{Алгоритм работы транслятора}
    \label{fig:translator}
\end{figure}

По этой причине часто применяются гибридные модели ЦПУ, в которых присутствуют как интерпретатор, так и транслятор. Когда модель исполняет «незацикленный» код, работает интерпретатор. Как только обнаруживается «горячий», т.е. часто исполняемый, цикл, моделирование его выполняется транслятором~\cite{TophamJones2007}.

\section{Увеличение скорости работы}

Были разработаны многочисленные приёмы увеличения скорости интерпретации. Рассмотрим базовые идеи, используемые при этом.

\subsection{Сцепленная интерпретация}

Одной из причин низкой скорости работы является неэффективное использование различных аппаратных ресурсов хозяйской системы, призванных уменьшить влияние явлений, разрушительных для конвейерной обработки. Так, из-за использования единого \texttt{switch} в теле цикла, из которого передача управления может быть осуществлена  во множество мест, предсказатель переходов процессора не может каждый раз правильно предугадать адрес инструкции перехода, что вызывает сброс конвейера и задержку в несколько тактов. Этот негативный эффект проявляется в начале обработки каждой новой гостевой инструкции. Вместо концентрации условного перехода в одном месте  желательно <<размазать>> его по многим местам в коде, уменьшив в каждом из них число вариантов адреса (в идеале --- до одного). Этого можно достичь, если вызывать обработчик следующей инструкции сразу после конца работы текущей инструкции, без возвращения в общий цикл. Такой алгоритм интерпретации называется \textit{сцепленным} (\abbr threaded). Пример реализации в псевдокоде дан ниже. Предполагается, что  этап декодирования уже проведён, и в памяти содержится информация о том, какой будет следующая инструкция.

\begin{lstlisting}
// Массив labels содержит адреса переходов для всех обработчиков.
labels = [INSTR_A, INSTRb, ... INSTR_X, ... INSTR_Y ...]; 

INSTR_X: // Текущая инструкция X
    X_handler(operands, PC); // обработчик инструкции
    PC++;
    goto label[PC]; // Сразу к обработчику новой инструкции

\end{lstlisting}

\subsection{Интерпретация с кэшированием}

Промежуточным звеном между интерпретатором и транслятором является кэширующий интерпретатор. В нём вместо достаточно медленной отдельной фазы генерации кода используется только кэш (промежуточное хранилище с быстрым доступом) декодированных инструкций (рис.~\ref{fig:cached-interp}). Если он реализован эффективно, то решение будет сбалансировано: при исполнении зацикленного кода модель ЦПУ будет достаточно быстрой, а при исполнении линейного кода будет незначительно проигрывать простому интерпретатору, рассмотренному ранее.

\begin{figure}[htb]
    \centering
    % \includegraphics[width=0.5\textwidth]{./cached-interp-crop}
    \begin{tikzpicture}[>=latex,
    action/.style={ rectangle, draw, node distance=2cm, text badly centered, text width=2.5cm},
    choice/.style={diamond, draw, aspect=2, node distance=2.5cm, text badly centered, text width=2.5cm, inner sep=0cm},
    complexaction/.style={rectangle, draw, rounded corners, node distance=2cm, text badly centered},
    ]
    \node[choice]       (is-decoded)   {\scriptsize Инструкция декодирована?};
    \node[action, below of=is-decoded] (fetch-instr)      {Извлечь инструкцию};
    \node[action, below of=fetch-instr] (decode)      {Декодировать};
    \node[complexaction, matrix, below of=decode, yshift=-1cm, row sep=0.1cm, text width=4cm]   (cache-decode) {
        \node{Сохранить декодированное представление}; \\
        \node[complexaction] {Управление хранилищем кода}; \\
        };
    \node[action, below of=cache-decode, yshift=-1cm] (execute)   {Исполнить};
    
    \path[->, draw] (is-decoded.east) -| ([xshift=2cm] execute.east) node[near start, above] {Да} -- (execute.east);
    \path[->, draw] (is-decoded.south) -- (fetch-instr.north) node[midway, right] {Нет};
    \path[->, draw] (fetch-instr.south) -- (decode.north);
    \path[->, draw] (decode.south) -- (cache-decode.north);
    \path[->, draw] (cache-decode.south) -- (execute.north);
    \path[->, draw] (execute.south) |-  ([xshift=-2cm, yshift=-1.0cm] execute.west) |- ([xshift=-2.5cm,yshift=0.5cm] is-decoded.north) -| (is-decoded.north);
    
    \end{tikzpicture}
    \caption{Схема работы кэширующего интерпретатора}
    \label{fig:cached-interp}
\end{figure}

\section{Модификация интерпретатора --- добавление новых инструкций}

Часто возникает задача расширения функциональности некоторой модели для представления функциональности нового процессора, отличающегося от старого наличием новых инструкций и дополнительных регистров процессора. Например, начиная с Intel Pentium IV в 2001 году были введены команды семейства SSE2, работающие с регистрами \texttt{XMM0}--\texttt{XMM7}.

Для того чтобы минимально модифицировать старый, хорошо отлаженный код модели, но при этом и поддержать новые системы, можно воспользоваться тем обстоятельством, что оригинальная модель не распознаёт новые инструкции как допустимые и должна вызвать обработку исключения \texttt{\#UD} (\abbr undefined opcode). Однако, мы даём модели <<второй шанс>>, вызывая второй декодер новых инструкций. Если он подтверждает, что может декодировать переданный ему машинный код, вызывается новая часть интерпретатора, ответственная за новый набор инструкций (рис.~\ref{fig:chained-interp}). 

\begin{figure}[htb]
    \centering
    \begin{tikzpicture}[>=latex,
    action/.style={ rectangle, draw, node distance=2cm, text badly centered, text width=2.5cm},
    choice/.style={diamond, draw, aspect=2, node distance=2cm, text badly centered, text width=2.5cm, inner sep=0cm}
    ]
    \node[action]                           (decode-d1)  {Декодировать, используя D1};
    \node[choice, below of=decode-d1]       (is-decoded) {Успешно декодирована?};
    \node[action, below of=is-decoded, yshift=-0.25cm]      (exec1)      {Исполнить обработчик};
    \node[action, below of=is-decoded, xshift=3cm]      (decode-d2)  {Декодировать, используя D2};
    \node[choice, below of=decode-d2]       (is-decoded-2)     {Успешно декодирована?};
    \node[action, below of=is-decoded-2, yshift=-0.25cm]    (exec2)    {Исполнить обработчик};
    \node[action, below of=is-decoded-2, xshift=3cm]      (exception)  {Перейти на обработчик исключения};
    \node[action, below of=exec2]           (next-instr)  {Перейти к следующей инструкции};
    
    \path[->, draw] (decode-d1.south) -- (is-decoded.north);
    \path[->, draw] (is-decoded.south) -- (exec1.north) node[midway, right] {Да};
    \path[->, draw] (is-decoded.east) -| (decode-d2.north) node[near start, above] {Нет};
    \path[->, draw] (exec1.south) |- (next-instr.west);
    \path[->, draw] (decode-d2.south) -- (is-decoded-2.north);
    \path[->, draw] (is-decoded-2.south) -- (exec2.north) node[midway, right] {Да};
    \path[->, draw] (is-decoded-2.east) -| (exception.north) node[near start, above] {Нет};
    \path[->, draw] (exec2.south) -- (next-instr.north);
    \path[->, draw] (exception.south) |- (next-instr.east);
    \path[->, draw] (next-instr.south) |-  ([xshift=-4cm, yshift=-1.5cm] next-instr.west) -| ([xshift=-2.5cm,yshift=0.5cm] decode-d1.north) -| (decode-d1.north);
    
    \end{tikzpicture}
    \caption[Ступенчатая схема вызова декодеров]{Ступенчатая схема вызова декодеров при обнаружении инструкции, не поддерживаемой оригинальной моделью. При обнаружении в потоке инструкций машинного кода, не распознаваемого D1, управление передаётся на D2}
    \label{fig:chained-interp}
\end{figure}

Очевидно, что данную схему можно расширить для каскадного включения большего числа новых наборов инструкций. Её достоинство --- гибкость подключения новой функциональности к уже существующей модели; дополнительные декодеры и симуляторы инструкций могут быть взяты из независимых источников и сравнительно легко адаптированы для использования. Недостаток тоже очевиден: последовательный вызов декодеров менее быстр, чем реализация, объединяющая их все в единую сущность.

\section{Заключительные замечания}
% Пример кода реализации интерпретации можно найти в репозитории проекта MDSP\footnote{\url{http://code.google.com/p/mdsp}}.

Проект Bochs~\cite{bochs} является хорошим примером зрелого интерпретатора, содержащего сложную модель процессора для существующей архитектуры IA-32. В технических заметках к программе~\cite{bochs-under-hood} её авторы описывают множество полезных приёмов, применимых как к организации модели-интерпретатора для процессора любой архитектуры, так и специфичных для архитектуры IA-32, являющейся одной из сложнейших в реализации.

\iftoggle{hasquiz}{
	\input{chapter03-questions}
}{}


\iftoggle{webpaper}{
    \printbibliography[title={Литература}]
}{}

